<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/><link rel="stylesheet" href="lpdoc.css" type="text/css"/><title>An Example - Documenting a Library Module &mdash; The lpdoc Documentation Generator v3.0</title></head><body><div class="nav"><span class="on_right"><a class="navbutton" href="meta_props.html">&#x25C4;</a><a class="navbutton" href="example_module.html">&#x25BA;</a></span><span><a href="lpdoc.html">The lpdoc Documentation Generator</a> &raquo; <a href="Reference.html">PART I - LPdoc Reference Manual</a> &raquo; </span></div><div class="documentwrapper"><div class="document"><div class="mainwrapper"><div class="main"><div id=""><h1>An Example - Documenting a Library Module</h1><a class="idx_anchor" href="lpdocliindex.html#lpdoc_examples"></a>
<strong>Author(s):</strong> <a class="idx_anchor" id="Manuel Hermenegildo" href="lpdocauindex.html#Manuel Hermenegildo">Manuel Hermenegildo</a>.<p>
<p><p>A simple example <a class="idx_anchor" id="0" href="lpdoccoindex.html#example of lpdoc use"></a> of the use of <a class="idx_anchor" id="1" href="lpdocglindex.html#lpdoc"><tt>lpdoc</tt></a> is this manual, which can be built in the <tt>doc</tt> directory of the <a class="idx_anchor" id="2" href="lpdocglindex.html#lpdoc"><tt>lpdoc</tt></a> distribution. Other examples of manuals generated using <a class="idx_anchor" id="3" href="lpdocglindex.html#lpdoc"><tt>lpdoc</tt></a> can be found in the <a class="idx_anchor" id="4" href="lpdocglindex.html#Ciao"><tt>Ciao</tt></a> system and preprocessor <tt>doc</tt> directories (i.e., most of the <a class="idx_anchor" id="5" href="lpdocglindex.html#Ciao"><tt>Ciao</tt></a> manuals are generated using <a class="idx_anchor" id="6" href="lpdocglindex.html#lpdoc"><tt>lpdoc</tt></a>). Some simpler examples can be found in the <tt>examples</tt> directory of the <a class="idx_anchor" id="7" href="lpdocglindex.html#lpdoc"><tt>lpdoc</tt></a> distribution. In particular, the chapter following this one contains the documentation generated automatically for the module defined by file <tt>examples/example_module.pl</tt> (which for simplicity contains only assertions, i.e., no actual code) and which is included in source form below. Comparing this code with the output in the following chapter illustrates the use and some of the capabilities of <a class="idx_anchor" id="8" href="lpdocglindex.html#lpdoc"><tt>lpdoc</tt></a>:<p><pre>%% The module headers produce documentation on the module interface 
%% Exported predicates (+ properties and types) are documented by default
:- module(example_module,
          [bar/1,baz/1,aorb/1,tree_of/2,list_or_aorb/2,q/2,r/1, p/1, p/5, u/3,
	   long/1, w/1, mytype/1, t/5, s/1, q/1],
          [assertions,basicmodes,fsyntax,regtypes,hiord,nativeprops]).  
 
%% We import two types: list/1 and list/2 (now in basic_props, which is 
%% exported by default from assertions). 

%% We reexport list/1
:- reexport(library(engine(basic_props)),[ list/1 ]).

:- use_module(library(lists), [length/2]).
%:- use_module(bar).
:- ensure_loaded(foo).

%% &quot;doc&quot; declarations provide additional information
:- doc(title,&quot;Auto Documenter Output for the Example Module&quot;).  

:- doc(author,&quot;Anonymous Author 1&quot;).  
:- doc(author,&quot;Anonymous Author 2&quot;).  

:- doc(summary,&quot;This is a brief summary description of the module
   or file. In this case the file is a library.&quot;).
 
:- doc(module,&quot;This is where general comments on the file go. In
   this case the file is a library which contains some assertion examples
   for testing the @em{automatic documentation system}. &quot;).

%% An example of a comment documenting a bug
:- doc(bug,&quot;Library is hard to execute: no actual code!&quot;).

%% Standard declarations are documented with the corresponding predicate
:- data r/1.
:- dynamic q/2.
:- multifile p/3.
:- dynamic p/3.
:- meta_predicate p(?,:,?).

%% Uncommenting this would make these not appear in the documentation
%% :- doc(hide,[bar/1,baz/1]).

%% This is a type definition in Prolog syntax: declaration and code
:- true regtype bar(X) # &quot;@var{X} is an acceptable kind of bar.&quot;.

bar(night).
bar(day).

%% This is another type definition in Prolog syntax, with no comment.
:- true regtype baz/1.

baz(a).
baz(b).

%% Two type definitions in &apos;typedef&apos; syntax (will be expanded to code as above)
%% :- typedef aorb ::= ^a;^b.
%% :- typedef listof_or_aorb(X) ::= list(X);aorb.

%% Using functional notation:
:- regtype aorb/1. 

aorb := a. 
aorb := b. 

%% Should use the other function syntax which uses *first argument* for return

:- regtype tree_of/2. 

tree_of(_) := void.
tree_of(T) := tree(~call(T),~tree_of(T),~tree_of(T)).

%% tree_of(_, void).
%% tree_of(T, tree(X,L,R)) :- 
%% 	T(X), 
%% 	tree_of(T,L), 
%% 	tree_of(T,R).

:- regtype list_or_aorb/2.

list_or_aorb(T)  := ~list(T).
list_or_aorb(_T) := ~aorb.

%% This is a property definition
%% This comment appears only in the place where the property itself 
%% is documented. 
:- doc(long/1,&quot;This is a property, describing a list that is longish. 
   The definition is: 

   @includedef{long/1}

   &quot;).

%% The comment here will be used to document any predicate which has an 
%% assertion which uses the property 
:- prop long(L) # &quot;@var{L} is rather long.&quot;.

long(L) :- 
	length(L,N),
	N&gt;100.

%% Now, a series of assertions:
%% 
%% This declares the entry mode of this exported predicate (i.e., 
%% how it is called from outside).
:- entry p/3 : gnd * var * var.

%% This describes all the calls
:- calls p/3 : foo * bar * baz.

foo(_).

%% This describes the successes (for a given type of calls)
:- success p/3 : int * int * var =&gt; int * int * gnd.

%% This describes a global property (for a given type of calls)
:- comp p/3 : int * int * var + not_fails.

:- doc(p/3,&quot;A @bf{general comment} on the predicate.&quot; ).
%% Documenting some typical usages of the predicate
:- pred p/3 
        : int * int * var 
       =&gt; int * int * list 
        + (iso,not_fails) 
        # &quot;This mode is nice.&quot;.
:- pred p(Preds,Value,Assoc) 
        : var * var * list
       =&gt; int * int * list 
        + not_fails # &quot;This mode is also nice.&quot;.
:- pred p/3 
       =&gt; list * int * list 
        + (not_fails,not_fails) 
        # &quot;Just playing around.&quot;.

:- pred q(A) 
        : list(A) 
       =&gt; (list(A),gnd(A)) 
        + not_fails
        # &quot;Foo&quot;.
:- pred q(A) 
        # &quot;Not a bad use at all.&quot;.

:- pred q/2 
        : var * {gnd,int} 
       =&gt; {gnd,int} * int.
:- pred q/2 
        :: int * list
        # &quot;Non-moded types are best used this way.&quot;.

q(_).

:- pred p/1 : var =&gt; list.

p(_).
 
:- pred r(A) 
        : list(A) 
       =&gt; (list(A,int),gnd(A)) 
        + not_fails
        # &quot;This uses parametric types&quot;.

:- doc(doinclude,s/1). %% Forces documentation even if not exported
:- pred s(A) 
        : list(A) 
       =&gt; (list(A),gnd(A)) 
        + not_fails.

s(_).

:- doc(doinclude,[list/2,list/1]). %% Forces (local) documentation even if 
                                       %% not exported 

:- modedef og(A) 
       =&gt; gnd(A) 
        # &quot;This is a @em{mode} definition: the output is ground.&quot;.

:- doc(doinclude,og/2).

:- modedef og(A,T) 
        :: T(A) 
        =&gt; gnd(A) 
        #  &quot;This is a @em{parametric mode definition}.&quot;.

:- pred t(+A,-B,?C,@D,og(E)) 
        :: list * list * int * int * list 
        :  long(B)
        =&gt; (gnd(C),gnd(A)) 
        +  not_fails 
        #  &quot;This predicate uses @em{modes} extensively.&quot;.

t(_, _, _, _, _).

%% Some other miscellaneous assertions:

%% Check is default assertion status anyway...
:- check pred u(+,-,og).
:- check pred u(int,list(mytype),int).

u(_, _, _).

%% &ldquo;true&rdquo; status is normally compiler output
:- true pred w(+list(mytype)).

mytype(_).

w(_).

:- doc(doinclude,is/2).

:- trust pred is(Num,Expr) : arithexpression(Expr) =&gt; num(Num)
   # &quot;Typical way to describe/document an external predicate (e.g.,
      written in C).&quot;.

:- doc(doinclude,p/5).
:- pred p(og(int),in,@list(int),-,+A) + steps_lb(1+length(A)).

p(_, _, _, _, _) :- _ is 1.

%% Version information. The ciao.el emacs mode allows automatic maintenance

</pre> <p><br/></div></div></div></div><div class="sidebarwrapper"><div class="sidebar"><IMG SRC="autofiglpdoc-logo-128.png"><h2>Global Links</h2><ul><LI><a href="lpdocfulltoc.html">Table of Contents</a><LI><a href="lpdocchanges.html">Version/Change Log</a><LI><a href="lpdocrefs.html">References</a><LI><a href="lpdoccopyright.html">Copyright</a></ul><h2>Indices</h2><ul><LI><a href="lpdocliindex.html">Library/Module Index</a><LI><a href="lpdocpdindex.html">Predicate/Method Index</a><LI><a href="lpdocprindex.html">Property Index</a><LI><a href="lpdocteindex.html">Regular Type Index</a><LI><a href="lpdocdeindex.html">Declaration Index</a><LI><a href="lpdoccoindex.html">Concept Index</a><LI><a href="lpdocauindex.html">Author Index</a><LI><a href="lpdocglindex.html">Global Index</a></ul></div></div><div class="clearer"></div></div><div class="nav"><span class="on_right"><a class="navbutton" href="meta_props.html">&#x25C4;</a><a class="navbutton" href="example_module.html">&#x25BA;</a></span><span>&nbsp;</span></div><div class="footer">Generated with LPdoc using Ciao</div></body></html>