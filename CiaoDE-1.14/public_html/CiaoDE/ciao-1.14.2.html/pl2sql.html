<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/><link rel="stylesheet" href="lpdoc.css" type="text/css"/><title>Prolog to SQL translator &mdash; The Ciao System v1.14#2</title></head><body><div class="nav"><span class="on_right"><a class="navbutton" href="persdbrt_mysql.html">&#x25C4;</a><a class="navbutton" href="mysql_client.html">&#x25BA;</a></span><span><a href="ciao.html">The Ciao System</a> &raquo; <a href="Interfaces.html">PART VIII - Interfaces to other languages and systems</a> &raquo; </span></div><div class="documentwrapper"><div class="document"><div class="mainwrapper"><div class="main"><div id=""><h1>Prolog to SQL translator</h1><a class="idx_anchor" href="ciaoliindex.html#pl2sql"></a>
<strong>Author(s):</strong> <a class="idx_anchor" id="Christoph Draxler" href="ciaoauindex.html#Christoph Draxler">Christoph Draxler</a>, <a class="idx_anchor" id="Manuel Hermenegildo" href="ciaoauindex.html#Manuel Hermenegildo">Manuel Hermenegildo (adaptation)</a>, <a class="idx_anchor" id="Ignacio Caballero" href="ciaoauindex.html#Ignacio Caballero">Ignacio Caballero (adaptation)</a>.<p>
This library performs translation of Prolog queries into <a class="idx_anchor" id="0" href="ciaoglindex.html#SQL">SQL</a>. The code is an adaptation for Ciao of the <a class="idx_anchor" id="1" href="ciaoglindex.html#Prolog to SQL compiler">Prolog to SQL compiler</a> written by Christoph Draxler, CIS Centre for Information and Speech Processing, Ludwig-Maximilians-University Munich, <tt>draxler@cis.uni-muenchen.de</tt>, Version 1.1. Many thanks to Christoph for allowing us to include this adaptation of his code with Ciao.<p>The translator needs to know the correspondence between Prolog predicates and the <a class="idx_anchor" id="2" href="ciaoglindex.html#SQL tables">SQL tables</a> in the database. To this end this module exports two multifile predicates, <a class="idx_anchor" id="3" href="ciaoglindex.html#sql__relation/3"><tt>sql__relation/3</tt></a> and <a class="idx_anchor" id="4" href="ciaoglindex.html#sql__attribute/4"><tt>sql__attribute/4</tt></a>. See the description of these predicates for details on how such correspondance is specified.<p>The main entry points to the translator are <a class="idx_anchor" id="5" href="ciaoglindex.html#pl2sqlstring/3"><tt>pl2sqlstring/3</tt></a> and <a class="idx_anchor" id="6" href="ciaoglindex.html#pl2sqlterm/3"><tt>pl2sqlterm/3</tt></a>. Details on the types of queries allowed can be found in the description of these predicates.<p><strong>Example:</strong> the following program would print out a term representing the SQL query corresponding to the given Prolog query:<p><pre>
</pre> <p><strong>Note</strong>: while the translator can be used directly in programs, it is more convenient to use a higher-level abstraction: <a class="idx_anchor" id="7" href="ciaoglindex.html#persistent predicates">persistent predicates</a> (implemented in the <a class="idx_anchor" id="8" href="ciaoglindex.html#persdb"><tt>persdb</tt></a> library). The notion of persistent predicates provides a completely transparent interface between Prolog and relational databases. When using this library, the Prolog to SQL translation is called automatically as needed.<p><br/><div id="Usage and interface"><h2>Usage and interface</h2><div class="cartouche"><ul><LI><strong>Library usage:</strong><br/><tt>:- use_module(library(pl2sql)).</tt><LI><strong>Exports:</strong><br/><ul class="itemize_minus"><LI><em>Predicates:</em><br/><a class="idx_anchor" id="9" href="ciaoglindex.html#pl2sqlstring/3"><tt>pl2sqlstring/3</tt></a>, <a class="idx_anchor" id="10" href="ciaoglindex.html#pl2sqlterm/3"><tt>pl2sqlterm/3</tt></a>, <a class="idx_anchor" id="11" href="ciaoglindex.html#sqlterm2string/2"><tt>sqlterm2string/2</tt></a>.
<LI><em>Regular Types:</em><br/><a class="idx_anchor" id="12" href="ciaoglindex.html#querybody/1"><tt>querybody/1</tt></a>, <a class="idx_anchor" id="13" href="ciaoglindex.html#projterm/1"><tt>projterm/1</tt></a>, <a class="idx_anchor" id="14" href="ciaoglindex.html#sqlstring/1"><tt>sqlstring/1</tt></a>.
<LI><em>Multifiles:</em><br/><a class="idx_anchor" id="15" href="ciaoglindex.html#sql__relation/3"><tt>sql__relation/3</tt></a>, <a class="idx_anchor" id="16" href="ciaoglindex.html#sql__attribute/4"><tt>sql__attribute/4</tt></a>.
</ul><LI><strong>Other modules used:</strong><br/><ul class="itemize_minus"><LI><em>System library modules:</em><br/><a class="idx_anchor" id="17" href="ciaoglindex.html#persdb_sql_common/sqltypes"><tt>persdb_sql_common/sqltypes</tt></a>, <a class="idx_anchor" id="18" href="ciaoglindex.html#iso_misc"><tt>iso_misc</tt></a>, <a class="idx_anchor" id="19" href="ciaoglindex.html#lists"><tt>lists</tt></a>, <a class="idx_anchor" id="20" href="ciaoglindex.html#aggregates"><tt>aggregates</tt></a>, <a class="idx_anchor" id="21" href="ciaoglindex.html#messages"><tt>messages</tt></a>.
</ul></ul></div></div><div id="Documentation on exports"><h2>Documentation on exports</h2><div><span class="on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="pl2sqlstring/3" href="ciaopdindex.html#pl2sqlstring/3">pl2sqlstring/3</a>:</div><div class="deftext"><p><strong>Usage:</strong> <tt>pl2sqlstring(ProjectionTerm,DatabaseGoal,SQLQueryString)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> This is the top level predicate which translates complex Prolog goals into the corresponding SQL code.<p>The query code is prepared in such a way that the result is projected onto the term <span class="var">ProjectionTerm</span> (also in a similar way to the first argument of <a class="idx_anchor" id="22" href="ciaoglindex.html#setof/3"><tt>setof/3</tt></a>)). See the predicate <a class="idx_anchor" id="23" href="ciaoglindex.html#translate_projection/3"><tt>translate_projection/3</tt></a> for restrictions on this term.<p><span class="var">SQLQueryString</span> contains the code of the <a class="idx_anchor" id="24" href="ciaoglindex.html#SQL query">SQL query</a>, ready to be sent to an <a class="idx_anchor" id="25" href="ciaoglindex.html#SQL server">SQL server</a>.<LI><em>Call and exit should be compatible with:</em><br/><span class="on_right"> (pl2sql:projterm/1)</span><span><span class="var">ProjectionTerm</span> is a database projection term.
</span><br/><span class="on_right"> (pl2sql:querybody/1)</span><span><span class="var">DatabaseGoal</span> is a database query goal.
</span><br/><span class="on_right"> (pl2sql:sqlstring/1)</span><span><span class="var">SQLQueryString</span> is a string containing SQL code.
</span>
<LI><em>The following properties should hold at call time:</em><br/><span class="on_right"> (term_typing:nonvar/1)</span><span><span class="var">ProjectionTerm</span> is currently a term which is not a free variable.
</span><br/><span class="on_right"> (term_typing:nonvar/1)</span><span><span class="var">DatabaseGoal</span> is currently a term which is not a free variable.
</span><br/><span class="on_right"> (term_typing:var/1)</span><span><span class="var">SQLQueryString</span> is a free variable.
</span>
</ul></div></div><p>
<div><span class="on_right">REGTYPE</span><div class="defname"><a class="idx_anchor" id="querybody/1" href="ciaoteindex.html#querybody/1">querybody/1</a>:</div><div class="deftext"><span class="var">DBGoal</span> is a goal meant to be executed in the external database. It can be a complex term containing <a class="idx_anchor" id="26" href="ciaoglindex.html#conjunctions">conjunctions</a>, <a class="idx_anchor" id="27" href="ciaoglindex.html#disjunctions">disjunctions</a>, and <a class="idx_anchor" id="28" href="ciaoglindex.html#negations">negations</a>, of:<p><ul> <p><LI><a class="idx_anchor" id="29" href="ciaoglindex.html#Atomic goals">Atomic goals</a>, which must have been defined via <a class="idx_anchor" id="30" href="ciaoglindex.html#sql__relation/3"><tt>sql__relation/3</tt></a> and <a class="idx_anchor" id="31" href="ciaoglindex.html#sql__attribute/4"><tt>sql__attribute/4</tt></a> and reside in the (same) database. Their arguments must be either ground or free variables. If they are ground, they must be bound to constants of the type declared for that argument. If an argument is a free variable, it may <em>share</em> with (i.e., be the same variable as) other free variables in other goal arguments.<p><LI><a class="idx_anchor" id="32" href="ciaoglindex.html#Database comparison goals">Database comparison goals</a>, whose main functor must be a <a class="idx_anchor" id="33" href="ciaoglindex.html#database comparison operator">database comparison operator</a> (see <a class="idx_anchor" id="34" href="ciaoglindex.html#pl2sql"><tt>pl2sql</tt></a>:<a class="idx_anchor" id="35" href="ciaoglindex.html#comparison/2"><tt>comparison/2</tt></a>) and whose arguments must be <em>database arithmetic expressions</em>.<p><LI><a class="idx_anchor" id="36" href="ciaoglindex.html#Database calls to is/2">Database calls to is/2</a>. The left side of such a call may be either unbound, in which case it is bound to the result of evaluating the right side, or bound in which case an equality condition is tested. The right side must be a <em>database arithmetic expression</em>.<p></ul> <p>The binding of variables follows Prolog rules:<p><ul> <p><LI>variables are bound by positive base goals and on the left side of the <a class="idx_anchor" id="37" href="ciaoglindex.html#is/2"><tt>is/2</tt></a> predicate.<p><LI>Comparison operations, negated goals, and right sides of the <a class="idx_anchor" id="38" href="ciaoglindex.html#is/2"><tt>is/2</tt></a> predicate do not return variable bindings and may even require all arguments to be bound for a safe evaluation.<p></ul> <p><a class="idx_anchor" id="39" href="ciaoglindex.html#Database arithmetic expressions">Database arithmetic expressions</a> may contain:<p><ul> <p><LI>Numeric constants (i.e., integers, reals, etc.).<p><LI>Bound variables, i.e., variables which will be bound during execution through occurrence within a positive database goal, or by a preceding arithmetic function.<p><LI><a class="idx_anchor" id="40" href="ciaoglindex.html#Database arithmetic functions">Database arithmetic functions</a>, which are a subset of those typically accepted within <a class="idx_anchor" id="41" href="ciaoglindex.html#is/2"><tt>is/2</tt></a> (see <a class="idx_anchor" id="42" href="ciaoglindex.html#pl2sql"><tt>pl2sql</tt></a>:<a class="idx_anchor" id="43" href="ciaoglindex.html#arithmetic_functor/2"><tt>arithmetic_functor/2</tt></a>).<p><LI><a class="idx_anchor" id="44" href="ciaoglindex.html#Database aggregation functions">Database aggregation functions</a>, each of which has two arguments: a variable indicating the argument over which the function is to be computed, and a goal argument which must contain in at least one argument position the variable (e.g. <tt>avg(Seats, plane(Type, Seats))</tt>). The goal argument may only be a conjunction of (positive or negative) base goals. See <a class="idx_anchor" id="45" href="ciaoglindex.html#pl2sql"><tt>pl2sql</tt></a>:<a class="idx_anchor" id="46" href="ciaoglindex.html#aggregate_functor/2"><tt>aggregate_functor/2</tt></a> for the admissible aggregate functions.<p></ul> <p>In addition, variables <a class="idx_anchor" id="47" href="ciaocoindex.html#existential quantification"></a> can be existentially quantified using <a class="idx_anchor" id="48" href="ciaoglindex.html#^/2"><tt>^/2</tt></a> (in a similar way to how it is done in <a class="idx_anchor" id="49" href="ciaoglindex.html#setof/3"><tt>setof/3</tt></a>).<p>Note that it is assumed that the arithmetic operators in Prolog and SQL are the same, i.e., <tt>+</tt> is addition in Prolog and in SQL, etc.<p><p><strong>Usage:</strong> <tt>querybody(DBGoal)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> <span class="var">DBGoal</span> is a database query goal.</ul></div></div><p>
<div><span class="on_right">REGTYPE</span><div class="defname"><a class="idx_anchor" id="projterm/1" href="ciaoteindex.html#projterm/1">projterm/1</a>:</div><div class="deftext"><span class="var">DBProjTerm</span> is a term onto which the result of a database query code is (in a similar way to the first argument of <a class="idx_anchor" id="50" href="ciaoglindex.html#setof/3"><tt>setof/3</tt></a>)).<p>A <span class="var">ProjectionTerm</span> must meet the following restrictions:<p><ul> <p><LI>The functor of <span class="var">ProjectionTerm</span> may not be one of the built-in predicates, i.e. &apos;,&apos;, &apos;;&apos;, etc. are not allowed.<p><LI>Only variables and constants are allowed as arguments, i.e., no structured terms may appear.<p></ul><p><strong>Usage:</strong> <tt>projterm(DBProjTerm)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> <span class="var">DBProjTerm</span> is a database projection term.</ul></div></div><p>
<div><span class="on_right">REGTYPE</span><div class="defname"><a class="idx_anchor" id="sqlstring/1" href="ciaoteindex.html#sqlstring/1">sqlstring/1</a>:</div><div class="deftext"><pre>sqlstring(S) :-
        string(S).
</pre><p><strong>Usage:</strong> <tt>sqlstring(S)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> <span class="var">S</span> is a string containing SQL code.</ul></div></div><p>
<div><span class="on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="pl2sqlterm/3" href="ciaopdindex.html#pl2sqlterm/3">pl2sqlterm/3</a>:</div><div class="deftext"><p><strong>Usage:</strong> <tt>pl2sqlterm(ProjectionTerm,DatabaseGoal,SQLQueryTerm)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> Similar to <a class="idx_anchor" id="51" href="ciaoglindex.html#pl2sqlstring/3"><tt>pl2sqlstring/3</tt></a> except that <span class="var">SQLQueryTerm</span> is a representation of the SQL query as a Prolog term.<LI><em>Call and exit should be compatible with:</em><br/><span class="on_right"> (pl2sql:projterm/1)</span><span><span class="var">ProjectionTerm</span> is a database projection term.
</span><br/><span class="on_right"> (pl2sql:querybody/1)</span><span><span class="var">DatabaseGoal</span> is a database query goal.
</span><br/><span class="on_right"> (basic_props:list/2)</span><span><span class="var">SQLQueryTerm</span> is a list of <span class="var">sqlterm</span>s.
</span>
<LI><em>The following properties should hold at call time:</em><br/><span class="on_right"> (term_typing:nonvar/1)</span><span><span class="var">ProjectionTerm</span> is currently a term which is not a free variable.
</span><br/><span class="on_right"> (term_typing:nonvar/1)</span><span><span class="var">DatabaseGoal</span> is currently a term which is not a free variable.
</span><br/><span class="on_right"> (term_typing:var/1)</span><span><span class="var">SQLQueryTerm</span> is a free variable.
</span>
</ul></div></div><p>
<div><span class="on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="sqlterm2string/2" href="ciaopdindex.html#sqlterm2string/2">sqlterm2string/2</a>:</div><div class="deftext"><p><strong>Usage:</strong> <tt>sqlterm2string(Queries,QueryString)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> <span class="var">QueryString</span> is a string representation of the list of queries in Prolog-term format in <span class="var">Queries</span>.<LI><em>Call and exit should be compatible with:</em><br/><span class="on_right"> (basic_props:list/2)</span><span><span class="var">Queries</span> is a list of <span class="var">sqlterm</span>s.
</span><br/><span class="on_right"> (pl2sql:sqlstring/1)</span><span><span class="var">QueryString</span> is a string containing SQL code.
</span>
<LI><em>The following properties should hold at call time:</em><br/><span class="on_right"> (term_typing:nonvar/1)</span><span><span class="var">Queries</span> is currently a term which is not a free variable.
</span><br/><span class="on_right"> (term_typing:var/1)</span><span><span class="var">QueryString</span> is a free variable.
</span>
</ul></div></div><p>
<div><span class="on_right">(UNDOC_REEXPORT)</span><div class="defname"><span class="idx_anchor" id="sqltype/1">sqltype/1</span>:</div><div class="deftext">
 Imported from <a class="idx_anchor" id="52" href="ciaoglindex.html#sqltypes"><tt>sqltypes</tt></a> (see the corresponding documentation for details).<br/></div></div><p>
</div><div id="Documentation on multifiles"><h2>Documentation on multifiles</h2><div><span class="on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="sql__relation/3" href="ciaopdindex.html#sql__relation/3">sql__relation/3</a>:</div><div class="deftext"><br/>
The predicate is <em>multifile</em>.<br/>
The predicate is of type <em>data</em>.<br/><p><strong>Usage:</strong> <tt>sql__relation(PredName,Arity,TableName)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> This predicate, together with <a class="idx_anchor" id="53" href="ciaoglindex.html#sql__attribute/4"><tt>sql__attribute/4</tt></a>, defines the correspondence between Prolog predicates and the <a class="idx_anchor" id="54" href="ciaoglindex.html#SQL tables">SQL tables</a> in the database. These two relations constitute an extensible meta-database which maps <a class="idx_anchor" id="55" href="ciaoglindex.html#Prolog predicate names">Prolog predicate names</a> to <a class="idx_anchor" id="56" href="ciaoglindex.html#SQL table names">SQL table names</a>, and <a class="idx_anchor" id="57" href="ciaoglindex.html#Prolog predicate argument positions">Prolog predicate argument positions</a> to <a class="idx_anchor" id="58" href="ciaoglindex.html#SQL attributes">SQL attributes</a>.<p><span class="var">PredName</span> is the chosen Prolog name for an SQL table. <span class="var">Arity</span> is the number of arguments of the predicate. <span class="var">TableName</span> is the name of the SQL table in the Database Management System.<LI><em>Call and exit should be compatible with:</em><br/><span class="on_right"> (basic_props:atm/1)</span><span><span class="var">PredName</span> is an atom.
</span><br/><span class="on_right"> (basic_props:int/1)</span><span><span class="var">Arity</span> is an integer.
</span><br/><span class="on_right"> (basic_props:atm/1)</span><span><span class="var">TableName</span> is an atom.
</span>
</ul></div></div><p>
<div><span class="on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="sql__attribute/4" href="ciaopdindex.html#sql__attribute/4">sql__attribute/4</a>:</div><div class="deftext"><br/>
The predicate is <em>multifile</em>.<br/>
The predicate is of type <em>data</em>.<br/><p><strong>Usage:</strong> <tt>sql__attribute(ANumber,TblName,AName,AType)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> This predicate maps the argument positions of a Prolog predicate to the SQL attributes of its corresponding table. The types of the arguments need to be specified, and this information is used for consistency checking during the translation and for output formatting. A minimal type system is provided to this end. The allowable types are given by <a class="idx_anchor" id="59" href="ciaoglindex.html#sqltype/1"><tt>sqltype/1</tt></a>.<p><span class="var">ANumber</span> is the argument number in the Prolog relation. <span class="var">TblName</span> is the name of the SQL table in the Database Management System. <span class="var">AName</span> is the name of the corresponding attribute in the table. <span class="var">AType</span> is the (translator) data type of the attribute.<LI><em>Call and exit should be compatible with:</em><br/><span class="on_right"> (basic_props:int/1)</span><span><span class="var">ANumber</span> is an integer.
</span><br/><span class="on_right"> (basic_props:atm/1)</span><span><span class="var">TblName</span> is an atom.
</span><br/><span class="on_right"> (basic_props:atm/1)</span><span><span class="var">AName</span> is an atom.
</span><br/><span class="on_right"> (sqltypes:sqltype/1)</span><span><span class="var">AType</span> is an SQL data type supported by the translator.
</span>
</ul></div></div><p>
</div><div id="Documentation on internals"><h2>Documentation on internals</h2><div><span class="on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="query_generation/3" href="ciaopdindex.html#query_generation/3">query_generation/3</a>:</div><div class="deftext"><p><strong>Usage:</strong> <tt>query_generation(ListOfConjunctions,ProjectionTerm,ListOfQueries)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> For each Conjunction in <span class="var">ListOfConjunctions</span>, translate the pair <tt>(ProjectionTerm, Conjunction)</tt> to an SQL query and connect each such query through a <a class="idx_anchor" id="60" href="ciaoglindex.html#UNION-operator">UNION-operator</a> to result in the <span class="var">ListOfQueries</span>.<p>A Conjunction consists of positive or negative subgoals. Each subgoal is translated as follows:<p><ul> <p><LI>the <a class="idx_anchor" id="61" href="ciaoglindex.html#functor of a goal">functor of a goal</a> that is not a comparison operation is translated to a <a class="idx_anchor" id="62" href="ciaoglindex.html#relation name">relation name</a> with a <a class="idx_anchor" id="63" href="ciaoglindex.html#range variable">range variable</a>,<p><LI><a class="idx_anchor" id="64" href="ciaoglindex.html#negated goals">negated goals</a> are translated to <a class="idx_anchor" id="65" href="ciaoglindex.html#NOT EXISTS-subqueries">NOT EXISTS-subqueries</a> with <a class="idx_anchor" id="66" href="ciaoglindex.html#* projection">* projection</a>,<p><LI><a class="idx_anchor" id="67" href="ciaoglindex.html#comparison operations">comparison operations</a> are translated to comparison operations in the <a class="idx_anchor" id="68" href="ciaoglindex.html#WHERE-clause">WHERE-clause</a>,<p><LI><a class="idx_anchor" id="69" href="ciaoglindex.html#aggregate function terms">aggregate function terms</a> are translated to <a class="idx_anchor" id="70" href="ciaoglindex.html#aggregate function (sub)queries">aggregate function (sub)queries</a>.<p></ul> <p>The arguments of a goal are translated as follows:<p><ul> <p><LI><span class="var">variables of a goal</span> are translated to <a class="idx_anchor" id="71" href="ciaoglindex.html#qualified attributes">qualified attributes</a>,<p><LI><a class="idx_anchor" id="72" href="ciaoglindex.html#variables occurring in several goals">variables occurring in several goals</a> are translated to equality comparisons (equi join) in the WHERE-clause, <a class="idx_anchor" id="73" href="ciaocoindex.html#equi join in the WHERE-clause"></a> <p><LI><a class="idx_anchor" id="74" href="ciaoglindex.html#constant arguments">constant arguments</a> are translated to <a class="idx_anchor" id="75" href="ciaoglindex.html#equality comparisons in the WHERE-clause">equality comparisons in the WHERE-clause</a>.<p></ul> <p>Arithmetic functions are treated specially (<a class="idx_anchor" id="76" href="ciaoglindex.html#translate_arithmetic_function/5"><tt>translate_arithmetic_function/5</tt></a>). See also <a class="idx_anchor" id="77" href="ciaoglindex.html#querybody/1"><tt>querybody/1</tt></a> for details on the syntax accepted and restrictions.<p><LI><em>The following properties should hold at call time:</em><br/><span class="on_right"> (term_typing:nonvar/1)</span><span><span class="var">ListOfConjunctions</span> is currently a term which is not a free variable.
</span><br/><span class="on_right"> (term_typing:nonvar/1)</span><span><span class="var">ProjectionTerm</span> is currently a term which is not a free variable.
</span><br/><span class="on_right"> (term_typing:var/1)</span><span><span class="var">ListOfQueries</span> is a free variable.
</span>
</ul></div></div><p>
<div><span class="on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="translate_conjunction/5" href="ciaopdindex.html#translate_conjunction/5">translate_conjunction/5</a>:</div><div class="deftext"><p><strong>Usage:</strong> <tt>translate_conjunction(Conjunction,SQLFrom,SQLWhere,Dict,NewDict)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> Translates a conjunction of goals (represented as a list of goals preceeded by existentially quantified variables) to <a class="idx_anchor" id="78" href="ciaoglindex.html#FROM-clauses">FROM-clauses</a> and <a class="idx_anchor" id="79" href="ciaoglindex.html#WHERE-clauses">WHERE-clauses</a> of an SQL query. A dictionary containing the associated SQL table and attribute names is built up as an accumulator pair (arguments <span class="var">Dict</span> and <span class="var">NewDict</span>).</ul></div></div><p>
<div><span class="on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="translate_goal/5" href="ciaopdindex.html#translate_goal/5">translate_goal/5</a>:</div><div class="deftext"><p><strong>Usage:</strong> <tt>translate_goal(Goal,SQLFrom,SQLWhere,Dict,NewDict)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> Translates:<p><ul> <p><LI>a <a class="idx_anchor" id="80" href="ciaoglindex.html#positive database goal">positive database goal</a> to the associated FROM- and WHERE clause of an SQL query,<p><LI>a <a class="idx_anchor" id="81" href="ciaoglindex.html#negated database goal">negated database goal</a> to a negated existential subquery,<p><LI>an <a class="idx_anchor" id="82" href="ciaoglindex.html#arithmetic goal">arithmetic goal</a> to an arithmetic expression or an aggregate function query,<p><LI>a <a class="idx_anchor" id="83" href="ciaoglindex.html#comparison goal">comparison goal</a> to a comparison expression, and<p><LI>a <a class="idx_anchor" id="84" href="ciaoglindex.html#negated comparison goal">negated comparison goal</a> to a comparison expression with the opposite comparison operator.<p></ul> </ul></div></div><p>
<div><span class="on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="translate_arithmetic_function/5" href="ciaopdindex.html#translate_arithmetic_function/5">translate_arithmetic_function/5</a>:</div><div class="deftext"><p><strong>Usage:</strong> <tt>translate_arithmetic_function(Result,Expression,SQLWhere,Dict,NewDict)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> Arithmetic functions (left side of is/2 operator is bound to value of expression on right side) may be called with either:<p><ul> <LI><span class="var">Result</span> unbound: then <span class="var">Result</span> is bound to the value of the evaluation of <span class="var">Expression</span>,<p><LI><span class="var">Result</span> bound: then an equality condition is returned between the value of <span class="var">Result</span> and the value of the evaluation of <span class="var">Expression</span>.<p>Only the equality test shows up in the WHERE clause of an SQLquery. </ul> </ul></div></div><p>
<div><span class="on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="translate_comparison/5" href="ciaopdindex.html#translate_comparison/5">translate_comparison/5</a>:</div><div class="deftext"><p><strong>Usage:</strong> <tt>translate_comparison(LeftArg,RightArg,CompOp,Dict,SQLComparison)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> Translates the left and right arguments of a comparison term into the appropriate comparison operation in SQL. The result type of each argument expression is checked for type compatibility.</ul></div></div><p>
<div><span class="on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="aggregate_function/3" href="ciaopdindex.html#aggregate_function/3">aggregate_function/3</a>:</div><div class="deftext"><p><strong>Usage:</strong> <tt>aggregate_function(AggregateFunctionTerm,Dict,AggregateFunctionQuery)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> Supports the Prolog aggregate function terms listed in <a class="idx_anchor" id="85" href="ciaoglindex.html#aggregate_functor/2"><tt>aggregate_functor/2</tt></a> within arithmetic expressions. Aggregate functions are translated to the corresponding SQL built-in aggregate functions.</ul></div></div><p>
<div><span class="on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="comparison/2" href="ciaopdindex.html#comparison/2">comparison/2</a>:</div><div class="deftext"><p><strong>Usage:</strong> <tt>comparison(PrologOperator,SQLOperator)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> Defines the mapping between Prolog operators and SQL operators: <pre>comparison(=,=).
comparison(&lt;,&lt;).
comparison(&gt;,&gt;).
comparison(@&lt;,&lt;).
comparison(@&gt;,&gt;).
</pre><LI><em>Call and exit should be compatible with:</em><br/><span class="on_right"> (basic_props:atm/1)</span><span><span class="var">PrologOperator</span> is an atom.
</span><br/><span class="on_right"> (basic_props:atm/1)</span><span><span class="var">SQLOperator</span> is an atom.
</span>
</ul></div></div><p>
<div><span class="on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="negated_comparison/2" href="ciaopdindex.html#negated_comparison/2">negated_comparison/2</a>:</div><div class="deftext"><p><strong>Usage:</strong> <tt>negated_comparison(PrologOperator,SQLOperator)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> Defines the mapping between Prolog operators and the complementary SQL operators: <pre>negated_comparison(=,&lt;&gt;).
negated_comparison(\==,=).
negated_comparison(&gt;,=&lt;).
negated_comparison(=&lt;,&gt;).
negated_comparison(&lt;,&gt;=).
negated_comparison(&gt;=,&lt;).
</pre><LI><em>Call and exit should be compatible with:</em><br/><span class="on_right"> (basic_props:atm/1)</span><span><span class="var">PrologOperator</span> is an atom.
</span><br/><span class="on_right"> (basic_props:atm/1)</span><span><span class="var">SQLOperator</span> is an atom.
</span>
</ul></div></div><p>
<div><span class="on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="arithmetic_functor/2" href="ciaopdindex.html#arithmetic_functor/2">arithmetic_functor/2</a>:</div><div class="deftext"><p><strong>Usage:</strong> <tt>arithmetic_functor(PrologFunctor,SQLFunction)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> Defines the admissible arithmetic functions on the Prolog side and their correspondence on the SQL side: <pre>arithmetic_functor(+,+).
arithmetic_functor(-,-).
arithmetic_functor(*,*).
arithmetic_functor(/,/).
</pre><LI><em>Call and exit should be compatible with:</em><br/><span class="on_right"> (basic_props:atm/1)</span><span><span class="var">PrologFunctor</span> is an atom.
</span><br/><span class="on_right"> (basic_props:atm/1)</span><span><span class="var">SQLFunction</span> is an atom.
</span>
</ul></div></div><p>
<div><span class="on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="aggregate_functor/2" href="ciaopdindex.html#aggregate_functor/2">aggregate_functor/2</a>:</div><div class="deftext"><p><strong>Usage:</strong> <tt>aggregate_functor(PrologFunctor,SQLFunction)</tt>
<ul class="itemize_minus"><LI><em>Description:</em> Defines the admissible aggregate functions on the Prolog side and their correspondence on the SQL side: <pre>aggregate_functor(avg,&apos;AVG&apos;).
aggregate_functor(min,&apos;MIN&apos;).
aggregate_functor(max,&apos;MAX&apos;).
aggregate_functor(sum,&apos;SUM&apos;).
aggregate_functor(count,&apos;COUNT&apos;).
</pre><LI><em>Call and exit should be compatible with:</em><br/><span class="on_right"> (basic_props:atm/1)</span><span><span class="var">PrologFunctor</span> is an atom.
</span><br/><span class="on_right"> (basic_props:atm/1)</span><span><span class="var">SQLFunction</span> is an atom.
</span>
</ul></div></div><p>
</div><div id="Known bugs and planned improvements"><h2>Known bugs and planned improvements</h2><ul><LI>Need to separate db predicate names by module.</ul></div></div></div></div></div><div class="sidebarwrapper"><div class="sidebar"><IMG SRC="autofigciao-shadow-64h.png"><h2>Module Sections</h2><ul><LI><a href="#Usage and interface">Usage and interface</a><LI><a href="#Documentation on exports">Documentation on exports</a><LI><a href="#Documentation on multifiles">Documentation on multifiles</a><LI><a href="#Documentation on internals">Documentation on internals</a><LI><a href="#Known bugs and planned improvements">Known bugs and planned improvements</a></ul><h2>Global Links</h2><ul><LI><a href="ciaofulltoc.html">Table of Contents</a><LI><a href="ciaochanges.html">Version/Change Log</a><LI><a href="ciaorefs.html">References</a><LI><a href="ciaocopyright.html">Copyright</a></ul><h2>Indices</h2><ul><LI><a href="ciaoliindex.html">Library/Module Index</a><LI><a href="ciaopdindex.html">Predicate/Method Index</a><LI><a href="ciaoprindex.html">Property Index</a><LI><a href="ciaoteindex.html">Regular Type Index</a><LI><a href="ciaodeindex.html">Declaration Index</a><LI><a href="ciaocoindex.html">Concept Index</a><LI><a href="ciaoauindex.html">Author Index</a><LI><a href="ciaoglindex.html">Global Index</a></ul></div></div><div class="clearer"></div></div><div class="nav"><span class="on_right"><a class="navbutton" href="persdbrt_mysql.html">&#x25C4;</a><a class="navbutton" href="mysql_client.html">&#x25BA;</a></span><span>&nbsp;</span></div><div class="footer">Generated with LPdoc using Ciao</div></body></html>