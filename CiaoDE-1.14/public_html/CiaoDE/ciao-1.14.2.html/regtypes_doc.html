<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/><link rel="stylesheet" href="lpdoc.css" type="text/css"/><title>Declaring regular types &mdash; The Ciao System v1.14#2</title></head><body><div class="nav"><span class="on_right"><a class="navbutton" href="assertions_props.html">&#x25C4;</a><a class="navbutton" href="native_props.html">&#x25BA;</a></span><span><a href="ciao.html">The Ciao System</a> &raquo; <a href="AnnotatedProlog.html">PART V - Assertions, Properties, Types, Modes, Comments (assertions)</a> &raquo; </span></div><div class="documentwrapper"><div class="document"><div class="mainwrapper"><div class="main"><div id=""><h1>Declaring regular types</h1><a class="idx_anchor" href="ciaoliindex.html#regtypes"></a>
<strong>Author(s):</strong> <a class="idx_anchor" id="Manuel Hermenegildo" href="ciaoauindex.html#Manuel Hermenegildo">Manuel Hermenegildo</a>, <a class="idx_anchor" id="Pedro Lopez" href="ciaoauindex.html#Pedro Lopez">Pedro L&oacute;pez</a>, <a class="idx_anchor" id="Francisco Bueno" href="ciaoauindex.html#Francisco Bueno">Francisco Bueno</a>.<p>
This library package adds declarations and new operator definitions which provide simple syntactic sugar to write <a class="idx_anchor" id="0" href="ciaoglindex.html#regular type definitions">regular type definitions</a> in source code. Regular types are just properties which have the additional characteristic of being <a class="idx_anchor" id="1" href="ciaoglindex.html#regular types">regular types</a> (<a class="idx_anchor" id="2" href="ciaoglindex.html#basic_props:regtype/1"><tt>basic_props:regtype/1</tt></a>), defined below.<p>For example, this library package allows writing: <pre>   :- regtype tree(X) # &quot;<span class="var">X</span> is a tree.&quot;.
   </pre> instead of the more cumbersome: <pre>   :- prop tree(X) + regtype # &quot;<span class="var">X</span> is a tree.&quot;.
   </pre> <p>Regular types can be used as properties to describe predicates and play an essential role in program debugging (see the Ciao Prolog preprocessor (<tt>ciaopp</tt>) manual).<p>In this chapter we explain some general considerations worth taking into account when writing properties in general, not just regular types.<p> <div id="Defining properties"><h2>Defining properties</h2> <p>Given the classes of assertions in the Ciao assertion language, there are two fundamental classes of properties. Properties used in assertions which refer to execution states (i.e., <tt>calls/1</tt>, <tt>success/1</tt>, and the like) are called <a class="idx_anchor" id="3" href="ciaocoindex.html#properties of execution states"><em>properties of execution states</em></a>. Properties used in assertions related to computations (i.e., <tt>comp/1</tt>) are called <a class="idx_anchor" id="4" href="ciaocoindex.html#properties of computations"><em>properties of computations</em></a>. Different considerations apply when writing a property of the former or of the later kind.<p>Consider a definition of the predicate <tt>string_concat/3</tt> which concatenates two character strings (represented as lists of ASCII codes): <pre>string_concat([],L,L).
string_concat([X|Xs],L,[X|NL]):- string_concat(Xs,L,NL).
</pre> <p>Assume that we would like to state in an assertion that each argument &ldquo;is a list of integers.&rdquo; However, we must decide which one of the following two possibilities we mean exactly: &ldquo;the argument is <em>instantiated</em> to a list of integers&rdquo; (let us call this property <tt>instantiated_to_intlist/1</tt>), or &ldquo;if any part of the argument is instantiated, this instantiation must be compatible with the argument being a list of integers&rdquo; (we will call this property <tt>compatible_with_intlist/1</tt>). For example, <tt>instantiated_to_intlist/1</tt> should be true for the terms <tt>[]</tt> and <tt>[1,2]</tt>, but should not for <tt>X</tt>, <tt>[a,2]</tt>, and <tt>[X,2]</tt>. In turn, <tt>compatible_with_intlist/1</tt> should be true for <tt>[]</tt>, <tt>X</tt>, <tt>[1,2]</tt>, and <tt>[X,2]</tt>, but should not be for <tt>[X|1]</tt>, <tt>[a,2]</tt>, and <tt>1</tt>. We refer to properties such as <tt>instantiated_to_intlist/1</tt> above as <a class="idx_anchor" id="5" href="ciaocoindex.html#instantiation properties"><em>instantiation properties</em></a> and to those such as <tt>compatible_with_intlist/1</tt> as <a class="idx_anchor" id="6" href="ciaocoindex.html#compatibility properties"><em>compatibility properties</em></a> (corresponding to the traditional notions of &ldquo;instantiation types&rdquo; and &ldquo;compatibility types&rdquo;).<p>It turns out that both of these notions are quite useful in practice. In the example above, we probably would like to use <tt>compatible_with_intlist/1</tt> to state that on success of <tt>string_concat/3</tt> all three argument must be compatible with lists of integers in an assertion like:<p><pre>:- success string_concat(A,B,C) =&gt; ( compatible_with_intlist(A),
                                     compatible_with_intlist(B),
                                     compatible_with_intlist(C) ).
</pre> <p>With this assertion, no error will be flagged for a call to <tt>string_concat/3</tt> such as <tt>string_concat([20],L,R)</tt>, which on success produces the resulting atom <tt>string_concat([20],L,[20|L])</tt>, but a call <tt>string_concat([],a,R)</tt> would indeed flag an error.<p>On the other hand, and assuming that we are running on a Prolog system, we would probably like to use <tt>instantiated_to_intlist/1</tt> for <tt>sumlist/2</tt> as follows:<p><pre>:- calls sumlist(L,N) : instantiated_to_intlist(L).

sumlist([],0).
sumlist([X|R],S) :- sumlist(R,PS), S is PS+X.
</pre> <p>to describe the type of calls for which the program has been designed, i.e., those in which the first argument of <tt>sumlist/2</tt> is indeed a list of integers.<p>The property <tt>instantiated_to_intlist/1</tt> might be written as in the following (Prolog) definition:<p><pre>:- prop instantiated_to_intlist/1.

instantiated_to_intlist(X) :- 
       nonvar(X), instantiated_to_intlist_aux(X).

instantiated_to_intlist_aux([]).
instantiated_to_intlist_aux([X|T]) :-
       integer(X), instantiated_to_intlist(T).
</pre> <p>(Recall that the Prolog builtin <tt>integer/1</tt> itself implements an instantiation check, failing if called with a variable as the argument.)<p>The property <tt>compatible_with_intlist/1</tt> might in turn be written as follows (also in Prolog):<p><pre>:- prop compatible_with_intlist/1.

compatible_with_intlist(X) :- var(X).
compatible_with_intlist(X) :- 
       nonvar(X), compatible_with_intlist_aux(X).

compatible_with_intlist_aux([]).
compatible_with_intlist_aux([X|T]) :-
       int_compat(X), compatible_with_intlist(T).

int_compat(X) :- var(X).
int_compat(X) :- nonvar(X), integer(X).
</pre> <p>Note that these predicates meet the criteria for being properties and thus the <tt>prop/1</tt> declaration is correct.<p>Ensuring that a property meets the criteria for &ldquo;not affecting the computation&rdquo; can sometimes make its coding somewhat tedious. In some ways, one would like to be able to write simply:<p><pre>intlist([]).
intlist([X|R]) :- int(X), intlist(R).
</pre> <p>(Incidentally, note that the above definition, provided that it suits the requirements for being a property and that <tt>int/1</tt> is a regular type, meets the criteria for being a regular type. Thus, it could be declared <tt>:- regtype intlist/1</tt>.)<p>But note that (independently of the definition of <tt>int/1</tt>) the definition above is not the correct instantiation check, since it would succeed for a call such as <tt>intlist(X)</tt>. In fact, it is not strictly correct as a compatibility property either, because, while it would fail or succeed as expected, it would perform instantiations (e.g., if called with <tt>intlist(X)</tt> it would bind <tt>X</tt> to <tt>[]</tt>). In practice, it is convenient to provide some run-time support to aid in this task.<p>The run-time support of the Ciao system (see <a href="rtchecks_doc.html">Run-time checking of assertions</a>) ensures that the execution of properties is performed in such a way that properties written as above can be used directly as instantiation checks. Thus, writing:<p><pre>:- calls sumlist(L,N) : intlist(L).
</pre> <p>has the desired effect. Also, the same properties can often be used as compatibility checks by writing them in the assertions as <tt>compat(Property)</tt> (<tt>basic_props:compat/1</tt>). Thus, writing:<p><pre>:- success string_concat(A,B,C) =&gt; ( compat(intlist(A)),
                                     compat(intlist(B)),
                                     compat(intlist(C)) ).
</pre> <p>also has the desired effect.<p>As a general rule, the properties that can be used directly for checking for compatibility should be <em>downwards closed</em>, i.e., once they hold they will keep on holding in every state accessible in forwards execution. There are certain predicates which are inherently <em>instantiation</em> checks and should not be used as <em>compatibility</em> properties nor appear in the definition of a property that is to be used with <tt>compat</tt>. Examples of such predicates (for Prolog) are <tt>==</tt>, <tt>ground</tt>, <tt>nonvar</tt>, <tt>integer</tt>, <tt>atom</tt>, <tt>&gt;</tt>, etc. as they require a certain instantiation degree of their arguments in order to succeed.<p>In contrast with properties of execution states, <em>properties of computations</em> refer to the entire execution of the call(s) that the assertion relates to. One such property is, for example, <tt>not_fail/1</tt> (note that although it has been used as in <tt>:- comp append(Xs,Ys,Zs) + not_fail</tt>, it is in fact read as <tt>not_fail(append(Xs,Ys,Zs))</tt>; see <tt>assertions_props:complex_goal_property/1</tt>). For this property, which should be interpreted as &ldquo;execution of the predicate either succeeds at least once or loops,&rdquo; we can use the following predicate <tt>not_fail/1</tt> for run-time checking:<p><pre>not_fail(Goal):-
      if( call(Goal),
          true,            %% then
          warning(Goal) ). %% else
</pre> <p>where the <tt>warning/1</tt> (library) predicate simply prints a warning message.<p>In this simple case, implementation of the predicate is not very difficult using the (non-standard) <tt>if/3</tt> builtin predicate present in many Prolog systems.<p><p>However, it is not so easy to code predicates which check other properties of the computation and we may in general need to program a meta-interpreter for this purpose.<p></div> <br/><div id="Usage and interface"><h2>Usage and interface</h2><div class="cartouche"><ul><LI><strong>Library usage:</strong><br/><tt>:- use_package(regtypes).</tt>

or

<tt>:- module(...,...,[regtypes]).</tt><LI><strong>New operators defined:</strong><br/><a class="idx_anchor" id="7" href="ciaoglindex.html#regtype/1"><tt>regtype/1</tt></a> [1150,fx], <a class="idx_anchor" id="8" href="ciaoglindex.html#regtype/2"><tt>regtype/2</tt></a> [1150,xfx].
<LI><strong>New declarations defined:</strong><br/><a class="idx_anchor" id="9" href="ciaoglindex.html#regtype/1"><tt>regtype/1</tt></a>, <a class="idx_anchor" id="10" href="ciaoglindex.html#regtype/2"><tt>regtype/2</tt></a>.
<LI><strong>Other modules used:</strong><br/><ul class="itemize_minus"><LI><em>System library modules:</em><br/><a class="idx_anchor" id="11" href="ciaoglindex.html#assertions/assertions_props"><tt>assertions/assertions_props</tt></a>.
</ul></ul></div></div><div id="Documentation on new declarations"><h2>Documentation on new declarations</h2><div><span class="on_right">DECLARATION</span><div class="defname"><a class="idx_anchor" id="regtype/1" href="ciaodeindex.html#regtype/1">regtype/1</a>:</div><div class="deftext"><a class="idx_anchor" id="12" href="ciaocoindex.html#regtype assertion"></a> This assertion is similar to a prop assertion but it flags that the property being documented is also a &ldquo;<a class="idx_anchor" id="13" href="ciaoglindex.html#regular type">regular type</a>.&rdquo; Regular types are properties whose definitions are <em>regular programs</em> (see lelow). This allows for example checking whether it is in the class of types supported by the regular type checking and inference modules.<p> A regular program is defined by a set of clauses, each of the form: <pre>p(x, v_1, ..., v_n)  :- body_1, ..., body_k.
</pre> where: <ol> <LI><tt>x</tt> is a term whose variables (which are called <em>term variables</em>) are unique, i.e., it is not allowed to introduce equality constraints between the variables of <tt>x</tt>.<p>For example, <tt>p(f(X, Y)) :- ...</tt> is valid, but <tt>p(f(X, X)) :- ...</tt> is not.<p><LI>in all clauses defining <tt>p/n+1</tt> the terms <tt>x</tt> do not unify except maybe for one single clause in which <tt>x</tt> is a variable.<p><LI><tt>n</tt> &gt;= 0 and <tt>p/n</tt> is a <a class="idx_anchor" id="14" href="ciaocoindex.html#parametric type functor"><em>parametric type functor</em></a> (whereas the predicate defined by the clauses is <tt>p/n</tt>+1).<p><LI><tt>v_1</tt>, ..., <tt>v_n</tt> are unique variables, which are called <em>parametric variables</em>.<p><LI>Each <tt>body_i</tt> is of the form:<p><ol> <LI><tt>t(z)</tt> where <tt>z</tt> is one of the <em>term variables</em> and <tt>t</tt> is a <em>regular type expression</em>;<p><LI><tt>q(y, t_1, ..., t_m)</tt> where <tt>m</tt> &gt;= 0, <tt>q/m</tt> is a <em>parametric type functor</em>, not in the set of functors <tt>=/2</tt>, <tt>^/2</tt>, <tt>./3</tt>.<p><tt>t_1, ..., t_m</tt> are <em>regular type expressions</em>, and <tt>y</tt> is a <em>term variable</em>. </ol> <p><LI>Each term variable occurs at most once in the clause&apos;s body (and should be as the first argument of a literal). </ol> A <a class="idx_anchor" id="15" href="ciaocoindex.html#regular type expression"><em>regular type expression</em></a> is either a parametric variable or a parametric type functor applied to some of the parametric variables.<p>A parametric type functor is a regular type, defined by a regular program, or a basic type. Basic types are defined in <a href="basic_props.html">Basic data types and properties</a>.<p><p><p> <p>The set of regular types is thus a well defined subset of the set of properties. Note that types can be used to describe characteristics of arguments in assertions and they can also be executed (called) as any other predicates. <p><strong>Usage:</strong> :- <tt>regtype AssertionBody</tt>.
<ul class="itemize_minus"><LI><em>The following properties should hold at call time:</em><br/><span class="on_right"> (assertions_props:assrt_body/1)</span><span><span class="var">AssertionBody</span> is an assertion body.
</span>
</ul></div></div><p>
<div><span class="on_right">DECLARATION</span><div class="defname"><a class="idx_anchor" id="regtype/2" href="ciaodeindex.html#regtype/2">regtype/2</a>:</div><div class="deftext"><a class="idx_anchor" id="16" href="ciaocoindex.html#regtype assertion"></a> This assertion is similar to a <a class="idx_anchor" id="17" href="ciaoglindex.html#regtype/1"><tt>regtype/1</tt></a> assertion but it is explicitely qualified. Non-qualified <a class="idx_anchor" id="18" href="ciaoglindex.html#regtype/1"><tt>regtype/1</tt></a> assertions are assumed the qualifier <tt>check</tt>. Note that checking regular type definitions should be done with the <tt>ciaopp</tt> preprocessor. <p><strong>Usage:</strong> :- <tt>AssertionStatus regtype AssertionBody</tt>.
<ul class="itemize_minus"><LI><em>The following properties should hold at call time:</em><br/><span class="on_right"> (assertions_props:assrt_status/1)</span><span><span class="var">AssertionStatus</span> is an acceptable status for an assertion.
</span><br/><span class="on_right"> (assertions_props:assrt_body/1)</span><span><span class="var">AssertionBody</span> is an assertion body.
</span>
</ul></div></div><p>
</div></div></div></div></div><div class="sidebarwrapper"><div class="sidebar"><IMG SRC="autofigciao-shadow-64h.png"><h2>Package Sections</h2><ul><LI><a href="#Defining properties">Defining properties</a><LI><a href="#Usage and interface">Usage and interface</a><LI><a href="#Documentation on new declarations">Documentation on new declarations</a></ul><h2>Global Links</h2><ul><LI><a href="ciaofulltoc.html">Table of Contents</a><LI><a href="ciaochanges.html">Version/Change Log</a><LI><a href="ciaorefs.html">References</a><LI><a href="ciaocopyright.html">Copyright</a></ul><h2>Indices</h2><ul><LI><a href="ciaoliindex.html">Library/Module Index</a><LI><a href="ciaopdindex.html">Predicate/Method Index</a><LI><a href="ciaoprindex.html">Property Index</a><LI><a href="ciaoteindex.html">Regular Type Index</a><LI><a href="ciaodeindex.html">Declaration Index</a><LI><a href="ciaocoindex.html">Concept Index</a><LI><a href="ciaoauindex.html">Author Index</a><LI><a href="ciaoglindex.html">Global Index</a></ul></div></div><div class="clearer"></div></div><div class="nav"><span class="on_right"><a class="navbutton" href="assertions_props.html">&#x25C4;</a><a class="navbutton" href="native_props.html">&#x25BA;</a></span><span>&nbsp;</span></div><div class="footer">Generated with LPdoc using Ciao</div></body></html>