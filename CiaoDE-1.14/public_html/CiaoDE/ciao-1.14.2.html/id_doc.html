<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/><link rel="stylesheet" href="lpdoc.css" type="text/css"/><title>Iterative-deepening execution &mdash; The Ciao System v1.14#2</title></head><body><div class="nav"><span class="on_right"><a class="navbutton" href="bf_doc.html">&#x25C4;</a><a class="navbutton" href="clpq_doc.html">&#x25BA;</a></span><span><a href="ciao.html">The Ciao System</a> &raquo; <a href="ExtendProlog.html">PART VII - Ciao extensions</a> &raquo; </span></div><div class="documentwrapper"><div class="document"><div class="mainwrapper"><div class="main"><div id=""><h1>Iterative-deepening execution</h1><a class="idx_anchor" href="ciaoliindex.html#id"></a>
<strong>Author(s):</strong> <a class="idx_anchor" id="Remy Haemmerle" href="ciaoauindex.html#Remy Haemmerle">R&eacute;my Haemmerl&eacute;</a>, <a class="idx_anchor" id="Manuel Carro" href="ciaoauindex.html#Manuel Carro">Manuel Carro</a>, <a class="idx_anchor" id="Claudio Vaucheret" href="ciaoauindex.html#Claudio Vaucheret">Claudio Vaucheret</a>, <a class="idx_anchor" id="Manuel Hermenegildo" href="ciaoauindex.html#Manuel Hermenegildo">Manuel Hermenegildo</a>.<p>
This package applies a <em>compiling control</em> technique to implement <a class="idx_anchor" id="0" href="ciaocoindex.html#depth first iterative deepening"><em>depth first iterative deepening</em></a> execution [<a href="ciaorefs.html#iterative-deepening">Kor85</a>]. It changes the usual <em>depth-first</em> computation rule by <a class="idx_anchor" id="1" href="ciaocoindex.html#iterative-deepening"><em>iterative-deepening</em></a> on those predicates specifically marked. This is very useful in search problems when a <a class="idx_anchor" id="2" href="ciaoglindex.html#complete proof procedure">complete proof procedure</a> is needed.<p>When this computation rule is used, first all goals are expanded only up to a given depth. If no solution is found or more solutions are needed by backtracking, the depth limit is incremented and the whole goal is repeated. Although it might seem that this approach is very inefficient because all higher levels are repeated for the deeper ones, it has been shown that is performs only about b/(b - 1) times as many operations than the corresponding breadth-first search, (where b is the branching factor of the proof tree) while the waste of memory is the same as depth first.<p>The usage is by means of the following directive:<p><tt>:- iterative(Name, FirstCut, Formula).</tt> <p>which states than the predicate &apos;Name&apos; given in functor/arity form will be executed using iterative deepening rule starting at the depth &apos;FirstCut&apos; with depth being incremented by the predicate &apos;Formula&apos;. This predicate compute the new depth using the previous one. It must implement a dilating function i.e. the new depth must be greater. For example, to start with depth 5 and increment by 10 you can write:<p><tt>:- iterative(p/1,5,f).</tt> <p><tt>f(X,Y) :- Y is X + 10.</tt> <p>or if you prefer,<p><tt>:- iterative(p/1,5,(_(X,Y):- Y is X + 10)).</tt> <p><a class="idx_anchor" id="3" href="ciaocoindex.html#depth limit"></a> You can also use a fourth parameter to set a limiting depth. All goals below the given depth limit simply fail. Thus, with the following directive:<p><tt>:- iterative(p/1,5,(_(X,Y):- Y is X + 10),100).</tt> <p>all goals deeper than 100 will fail.<p>An example of code using this package would be:<p><pre>:- module(example_id, _,[id]).

test(id) :- 
	idchain(a,d).
test(df) :- 
	chain(a,d).   % loops!

:- iterative(idchain/2, 3, ( _(X,Z) :- Z is X + 1) ).

idchain(X,X).
idchain(X,Y) :- 
	arc(X,Z), 
	idchain(Z,Y).

chain(X,X).
chain(X,Y) :- 
	arc(X,Z), 
	chain(Z,Y).

arc(a,b).
arc(a,d).
arc(b,c).
arc(c,a).

</pre> <p>The order of solutions are first the shallower and then the deeper. Solutions which are between two cutoff are given in the usual left to right order. For example,<p><pre>:- module(_,_,[id]).

% All goals deeper than 2 will fail
:- iterative(p/1,0,(_(X,Z) :- Z is X + 1),2).

% Change the solutions&apos; order to goal p(X). 
%:- iterative(p/1,1,(_(X,Z) :- Z is X + 3)).

p(X) :- q(X).
p(a).

q(X) :- r(X).
q(b).

r(X) :- s(X).
r(c).

s(d).

</pre> <p>Another complete proof procedure implemented is the <a class="idx_anchor" id="4" href="ciaoglindex.html#bf"><tt>bf</tt></a> package (<a class="idx_anchor" id="5" href="ciaoglindex.html#breadth first execution">breadth first execution</a>).<br/><div id="Usage and interface"><h2>Usage and interface</h2><div class="cartouche"><ul><LI><strong>Library usage:</strong><br/><tt>:- use_package(id).</tt>

or

<tt>:- module(...,...,[id]).</tt></ul></div></div></div></div></div></div><div class="sidebarwrapper"><div class="sidebar"><IMG SRC="autofigciao-shadow-64h.png"><h2>Package Sections</h2><ul><LI><a href="#Usage and interface">Usage and interface</a></ul><h2>Global Links</h2><ul><LI><a href="ciaofulltoc.html">Table of Contents</a><LI><a href="ciaochanges.html">Version/Change Log</a><LI><a href="ciaorefs.html">References</a><LI><a href="ciaocopyright.html">Copyright</a></ul><h2>Indices</h2><ul><LI><a href="ciaoliindex.html">Library/Module Index</a><LI><a href="ciaopdindex.html">Predicate/Method Index</a><LI><a href="ciaoprindex.html">Property Index</a><LI><a href="ciaoteindex.html">Regular Type Index</a><LI><a href="ciaodeindex.html">Declaration Index</a><LI><a href="ciaocoindex.html">Concept Index</a><LI><a href="ciaoauindex.html">Author Index</a><LI><a href="ciaoglindex.html">Global Index</a></ul></div></div><div class="clearer"></div></div><div class="nav"><span class="on_right"><a class="navbutton" href="bf_doc.html">&#x25C4;</a><a class="navbutton" href="clpq_doc.html">&#x25BA;</a></span><span>&nbsp;</span></div><div class="footer">Generated with LPdoc using Ciao</div></body></html>