<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/><link rel="stylesheet" href="lpdoc.css" type="text/css"/><title>The stand-alone command-line compiler &mdash; The Ciao System v1.14#2</title></head><body><div class="nav"><span class="on_right"><a class="navbutton" href="DevEnv.html">&#x25C4;</a><a class="navbutton" href="toplevel_doc.html">&#x25BA;</a></span><span><a href="ciao.html">The Ciao System</a> &raquo; <a href="DevEnv.html">PART I - The program development environment</a> &raquo; </span></div><div class="documentwrapper"><div class="document"><div class="mainwrapper"><div class="main"><div id=""><h1>The stand-alone command-line compiler</h1>
<strong>Author(s):</strong> <a class="idx_anchor" id="Daniel Cabeza" href="ciaoauindex.html#Daniel Cabeza">Daniel Cabeza</a>, <a class="idx_anchor" id="Edison Mera" href="ciaoauindex.html#Edison Mera">Edison Mera</a>, <a class="idx_anchor" id="The CLIP Group" href="ciaoauindex.html#The CLIP Group">The CLIP Group</a>.<p>
<a class="idx_anchor" id="0" href="ciaocoindex.html#compiling, from command line"></a> <a class="idx_anchor" id="1" href="ciaocoindex.html#compiler, standalone"></a> <a class="idx_anchor" id="2" href="ciaoglindex.html#ciaoc"><tt>ciaoc</tt></a> [<a href="ciaorefs.html#ciaoc-entcs">CH00b</a>] is the Ciao stand-alone command-line compiler. <a class="idx_anchor" id="3" href="ciaoglindex.html#ciaoc"><tt>ciaoc</tt></a> can be used to create executables or to compile individual files to object code (to be later linked with other files). <a class="idx_anchor" id="4" href="ciaoglindex.html#ciaoc"><tt>ciaoc</tt></a> is specially useful when working from the command line. Also, it can be called to compile Ciao programs from other tools such as, e.g., <a class="idx_anchor" id="5" href="ciaoglindex.html#shell scripts">shell scripts</a>, <a class="idx_anchor" id="6" href="ciaoglindex.html#Makefile"><tt>Makefile</tt></a>s, or <a class="idx_anchor" id="7" href="ciaoglindex.html#project files">project files</a>. All the capabilities of <a class="idx_anchor" id="8" href="ciaoglindex.html#ciaoc"><tt>ciaoc</tt></a> are also available from the interactive top-level shell, which uses the ciaoc modules as its components.<p><div id="Introduction to building executables"><h2>Introduction to building executables</h2> <p>An <a class="idx_anchor" id="9" href="ciaocoindex.html#executable"><em>executable</em></a> can be built from a single file or from a collection of inter-related files. In the case of only one file, this file must define the predicate <a class="idx_anchor" id="10" href="ciaoglindex.html#main/0"><tt>main/0</tt></a> or <a class="idx_anchor" id="11" href="ciaoglindex.html#main/1"><tt>main/1</tt></a>. This predicate is the one which will be called when the executable is started. As an example, consider the following file, called <tt>hello.pl</tt>:<p><pre>main :-
     write(&apos;Hello world&apos;), 
     nl.
</pre> <p>To compile it from the command line using the <a class="idx_anchor" id="12" href="ciaoglindex.html#ciaoc"><tt>ciaoc</tt></a> standalone compiler it suffices to type &ldquo;<tt>ciaoc hello</tt>&rdquo; (in Win32 you may have to put the complete path to the <a class="idx_anchor" id="13" href="ciaoglindex.html#ciaoc"><tt>ciaoc</tt></a> folder of the Ciao distribution, where the installation process leaves a <a class="idx_anchor" id="14" href="ciaoglindex.html#ciaoc.bat"><tt>ciaoc.bat</tt></a> file):<p><pre>/herme@clip:/tmp
[60]&gt; ciaoc hello

/herme@clip:/tmp
[61]&gt; 
</pre> <p>This produces an executable called <tt>hello</tt> in Un*x-like systems and <tt>hello.cpx</tt> under Win32 systems. This executable can then be run in Win32 by double-clicking on it and on Un*x systems by simply typing its name (see for <a href="#Running executables from the command line">Running executables from the command line</a> for how to run executables from the command line in Win32):<p><pre>/herme@clip:/tmp
[61]&gt; hello
Hello world

</pre> <p>If the application is composed of several files the process is identical. Assume <tt>hello.pl</tt> is now:<p><pre>:- use_module(aux, [p/1]).

main :-
     p(X),
     write(X), 
     nl.
</pre> <p>where the file <tt>aux.pl</tt> contains:<p><pre>:- module(aux,[p/1]).

p(&apos;Hello world&apos;).
</pre> <p>This can again be compiled using the <a class="idx_anchor" id="15" href="ciaoglindex.html#ciaoc"><tt>ciaoc</tt></a> standalone compiler as before:<p><pre>/herme@clip:/tmp
[60]&gt; ciaoc hello

/herme@clip:/tmp
[61]&gt; hello
Hello world

</pre> <p>The invocation of <tt>ciaoc hello</tt> compiles the file <tt>hello.pl</tt> and all connected files that may need recompilation -- in this case the file <tt>aux.pl</tt>. Also, if any library files used had not been compiled previously they would be compiled at this point (See <a href="#Intermediate files in the compilation process">Intermediate files in the compilation process</a>). Also, if, say, <tt>hello.pl</tt> is changed and recompiled, the object code resulting from the previous compilation of <tt>aux.pl</tt> will be reused. This is all done without any need for <tt>Makefile</tt>s, and considerably accelerates the development process for large applications. This process can be observed by selecting the <tt>-v</tt> option when invoking <tt>ciaoc</tt> (which is equivalent to setting the <tt>verbose_compilation</tt> Prolog flag to <tt>on</tt> in the top-level interpreter).<p>If <a class="idx_anchor" id="16" href="ciaoglindex.html#main/1"><tt>main/1</tt></a> is defined instead of <a class="idx_anchor" id="17" href="ciaoglindex.html#main/0"><tt>main/0</tt></a> then when the executable is started the argument of <a class="idx_anchor" id="18" href="ciaoglindex.html#main/1"><tt>main/1</tt></a> will be instantiated to a list of atoms, each one of them corresponding to a command line option. Consider the file <tt>say.pl</tt>:<p><pre>main(Argv) :-
     write_list(Argv), nl.

write_list([]).
write_list([Arg|Args]) :- 
     write(Arg),
     write(&apos; &apos;),
     write_list(Args).
</pre> <p>Compiling this program and running it results in the following output:<p><pre>/herme@clip:/tmp
[91]&gt; ciaoc say

/herme@clip:/tmp
[91]&gt; say hello dolly
hello dolly 
</pre> <p>The name of the generated executable can be controlled with the <tt>-o</tt> option (See <a href="#Usage (ciaoc)">Usage (ciaoc)</a>).<p></div><div id="Paths used by the compiler during compilation"><h2>Paths used by the compiler during compilation</h2> <p>The compiler will look for files mentioned in commands such as <a class="idx_anchor" id="19" href="ciaoglindex.html#use_module/1"><tt>use_module/1</tt></a> or <a class="idx_anchor" id="20" href="ciaoglindex.html#ensure_loaded/1"><tt>ensure_loaded/1</tt></a> in the current directory. Other paths can be added by including them in a file whose name is given to <tt>ciaoc</tt> using the <tt>-u</tt> option. This file should contain facts of the predicates <a class="idx_anchor" id="21" href="ciaoglindex.html#file_search_path/2"><tt>file_search_path/2</tt></a> and <a class="idx_anchor" id="22" href="ciaoglindex.html#library_directory/1"><tt>library_directory/1</tt></a> (see the documentation for these predicates and also <a href="libpaths.html">Customizing library paths and path aliases</a> for details).<p></div><div id="Running executables from the command line"><h2>Running executables from the command line</h2> <a class="idx_anchor" id="23" href="ciaocoindex.html#executables, how to run"></a> <p>As mentioned before, what the <tt>ciaoc</tt> compiler generates and how it is started varies somewhat from OS to OS. In general, the product of compiling an application with <tt>ciaoc</tt> is a file that contains the bytecode (the product of the compilation) and invokes the <a class="idx_anchor" id="24" href="ciaoglindex.html#Ciao engine">Ciao engine</a> on it.<p><ul> <p><LI>Un Un*x this is a <em>script</em> (see the first lines of the file) which invokes the ciao engine on this file. To run the generated executable from a Un*x shell, or from the <a class="idx_anchor" id="25" href="ciaoglindex.html#bash"><tt>bash</tt></a> shell that comes with the Cygwin libraries (see <a href="Install.html#Installation and compilation under Windows">Installation and compilation under Windows</a>) it suffices to type its name at the shell command line, as in the examples above.<p><LI>In a Win32 system, the compiler produces a similar file with a <tt>.cpx</tt> ending. The Ciao installation process typically makes sure that the Windows registry contains the right entries so that this executable will run upon double-cliking on it.<p>In you want to run the executable from the command line an additional <tt>.bat</tt> file is typically needed. To help in doing this, the Win32 installation process creates a <tt>.bat</tt> skeleton file called <tt>bat_skel</tt> in the <a class="idx_anchor" id="26" href="ciaoglindex.html#Win32"><tt>Win32</tt></a> folder of the distribution) which allows running Ciao executables from the command line. If you want to run a Ciao executable <tt>file.cpx</tt> from the command line, you normally copy the skeleton file to the folder were the executable is and rename it to <tt>file.bat</tt>, then change its contents as explained in a comment inside the file itself.<p>Note that this <tt>.bat</tt> file is usually not necessary in NT, as its command shell understands file extension associations. I.e., in windows NT it is possible to run the <tt>file.cpx</tt> executable directly. Due to limitations of <tt>.bat</tt> files in Windows 95/98, in those OSs no more than 9 command line arguments can be passed to the executable (in NT there is no such restriction).<p>Finally, in a system in which Cygnus Win32 is installed executables can also be used directly from the <a class="idx_anchor" id="27" href="ciaoglindex.html#bash"><tt>bash</tt></a> shell command line, without any associated <tt>.bat</tt> files, by simply typing their name at the <a class="idx_anchor" id="28" href="ciaoglindex.html#bash"><tt>bash</tt></a> shell command line, in the same way as in Un*x. This only requires that the <a class="idx_anchor" id="29" href="ciaoglindex.html#bash"><tt>bash</tt></a> shell which comes with Cygnus Win32 be installed and accessible: simply, make sure that <a class="idx_anchor" id="30" href="ciaoglindex.html#/bin/sh.exe"><tt>/bin/sh.exe</tt></a> exists.<p></ul> <p>Except for a couple of header lines, the contents of executables are almost identical under different OSs (except for self-contained ones). The bytecode they contain is architecture-independent. In fact, it is possible to create an executable under Un*x and run it on Windows or viceversa, by making only minor modifications (e.g., creating the <tt>.bat</tt> file and/or setting environment variables or editing the start of the file to point to the correct engine location).<p></div><div id="Types of executables generated"><h2>Types of executables generated</h2> <p><a class="idx_anchor" id="31" href="ciaocoindex.html#executables, types"></a> <p>While the default options used by <a class="idx_anchor" id="32" href="ciaoglindex.html#ciaoc"><tt>ciaoc</tt></a> are sufficient for normal use, by selecting other options <a class="idx_anchor" id="33" href="ciaoglindex.html#ciaoc"><tt>ciaoc</tt></a> can generate several different types of executables, which offer interesting tradeoffs among size of the generated executable, portability, and startup time [<a href="ciaorefs.html#ciaoc-entcs">CH00b</a>]:<p><dl> <p><DT>Dynamic executables:<dd> <a class="idx_anchor" id="34" href="ciaocoindex.html#executables, dynamic"></a> <p><a class="idx_anchor" id="35" href="ciaoglindex.html#ciaoc"><tt>ciaoc</tt></a> produces by default <em>dynamic</em> executables. In this case the executable produced is a <a class="idx_anchor" id="36" href="ciaoglindex.html#platform-independent">platform-independent</a> file which includes in compiled form all the user defined files. On the other hand, any system libraries used by the application are loaded dynamically at startup. More precisely, any files that appear as <tt>library(...)</tt> in <a class="idx_anchor" id="37" href="ciaoglindex.html#use_module/1"><tt>use_module/1</tt></a> and <a class="idx_anchor" id="38" href="ciaoglindex.html#ensure_loaded/1"><tt>ensure_loaded/1</tt></a> declarations will not be included explicitly in the executable and will instead be loaded dynamically. Is is also possible to mark other <a class="idx_anchor" id="39" href="ciaoglindex.html#path aliases">path aliases</a> (see the documentation for <a class="idx_anchor" id="40" href="ciaoglindex.html#file_search_path/2"><tt>file_search_path/2</tt></a>) for dynamic loading by using the <tt>-d</tt> option. Files accessed through such aliases will also be loaded dynamically.<p>Dynamic loading allows making smaller executables. Such executables may be used directly in the same machine in which they were compiled, since suitable paths to the location of the libraries will be included as default in the executable by <a class="idx_anchor" id="41" href="ciaoglindex.html#ciaoc"><tt>ciaoc</tt></a> during compilation.<p>The executable can also be used in another machine, even if the architecture and OS are different. The requirement is that the Ciao libraries (which will also include the appropriate <a class="idx_anchor" id="42" href="ciaoglindex.html#Ciao engine">Ciao engine</a> for that architecture and OS) be installed in the target machine, and that the <tt>CIAOLIB</tt> and <tt>CIAOENGINE</tt> environment variables are set appropriately for the executable to be able to find them (see <a href="#Environment variables used by Ciao executables">Environment variables used by Ciao executables</a>). How to do this differs slightly from OS to OS.<p><DT>Static executables:<dd> <a class="idx_anchor" id="43" href="ciaocoindex.html#executables, static"></a> <p>Selecting the <tt>-s</tt> option <tt>ciaoc</tt> produces a <em>static</em> executable. In this case the executable produced (again a <a class="idx_anchor" id="44" href="ciaoglindex.html#platform-independent">platform-independent</a> file) will include in it all the auxiliary files and any system libraries needed by the application. Thus, such an executable is almost complete, needing in order to run only the <a class="idx_anchor" id="45" href="ciaoglindex.html#Ciao engine">Ciao engine</a>, which is platform-specific.<P><b>Note:</b> Currently there is an exception to this related to libraries which are written in languages other than Prolog, as, e.g., C. C files are currently always compiled to dynamically loadable object files (<tt>.so</tt> files), and they thus need to be included manually in a distribution of an application. This will be automated in upcoming versions of the Ciao system.<P> Again, if the executable is run in the same machine in which it was compiled then the engine is found automatically. If the executable is moved to another machine, the executable only needs access to a suitable engine (which can be done by setting the <tt>CIAOENGINE</tt> environment variable to point to this engine).<p>This type of compilation produces larger executables, but has the advantage that these executables can be installed and run in a different machine, with different architecture and OS, even if Ciao is not installed on that machine. To install (or distribute) such an executable, one only needs to copy the executable file itself and the appropriate engine for the target platform (See <a href="Install.html">Installing Ciao from the source distribution</a> or <a href="InstallWin32bin.html">Installing Ciao from a Win32 binary distribution</a> and <a href="Install.html#Multiarchitecture support">Multiarchitecture support</a>), and to set things so that the executable can find the engine. <P><b>Note:</b> It is also possible to produce real standalone executables, i.e., executables that do not need to have an engine around. However, this is not automated yet, although it is planned for an upcoming version of the compiler. In particular, the compiler can generate a <tt>.c</tt> file for each <tt>.pl</tt> file. Then all the <tt>.c</tt> files can be compiled together into a real executable (the engine is added one more element during link time) producing a complete executable for a given architecture. The downside of course is that such an executable will not be portable to other architectures without recompilation.<P> <p><DT>Dynamic executables, with lazy loading:<dd> <a class="idx_anchor" id="46" href="ciaocoindex.html#executables, lazy load"></a> <p>Selecting the <tt>-l</tt> option is very similar to the case of dynamic executables above, except that the code in the library modules is not loaded when the program is started but rather it is done during execution, the first time a predicate defined in that file is called. This is advantageous if a large application is composed of many parts but is such that typically only some of the parts are used in each invocation. The Ciao preprocessor, <a class="idx_anchor" id="47" href="ciaoglindex.html#ciaopp"><tt>ciaopp</tt></a>, is a good example of this: it has many capabilitites but typically only some of them are used in a given session. An executable with lazy load has the advantage that it starts fast, loading a minimal functionality on startup, and then loads the different modules automatically as needed.<p><DT>Self-contained executables:<dd> <a class="idx_anchor" id="48" href="ciaocoindex.html#executables, self-contained"></a> <p><em>Self-contained</em> executables are static executables (i.e., this option also implies <em>static</em> compilation) which include a Ciao engine along with the bytecode, so they do not depend on an external one for their execution. This is useful to create executables which run even if the machine where the program is to be executed does not have a Ciao engine installed and/or libraries. The disadvantage is that such execuatbles are <a class="idx_anchor" id="49" href="ciaoglindex.html#platform-dependent">platform-dependent</a> (as well as larger than those that simply use an external library). This type of compilation is selected with the <tt>-S</tt> option. Cross-compilation is also possible with the <tt>-SS</tt> option, so you can specify the target OS and architecture (e.g. LINUXi86). To be able to use the latter option, it is necessary to have installed a ciaoengine for the target machine in the Ciao library (this requires compiling the engine in that OS/architecture and installing it, so that it is available in the library).<p><DT>Compressed executables:<dd> <a class="idx_anchor" id="50" href="ciaocoindex.html#executables, compressed"></a> <p>In <em>compressed</em> executables the bytecode is compressed. This allows producing smaller executables, at the cost of a slightly slower startup time. This is selected with the <tt>-z</tt> option. You can also produce compressed libraries if you use <tt>-zl</tt> along with the <tt>-c</tt> option. If you select <tt>-zl</tt> while generating an executable, any library which is compiled to accomplish this will be also compressed.<p><DT>Active modules:<dd> <a class="idx_anchor" id="51" href="ciaocoindex.html#modules, active"></a> <p>The compiler can also compile (via the <tt>-a</tt> option) a given file into an <a class="idx_anchor" id="52" href="ciaocoindex.html#active module"><em>active module</em></a> (see <a href="actmods_doc.html">Active modules (high-level distributed execution)</a> for a description of this).<p><p></dl> <p></div><div id="Environment variables used by Ciao executables"><h2>Environment variables used by Ciao executables</h2> <p>The executables generated by the Ciao compiler (including the ciao development tools themselves) locate automatically where the Ciao engine and libraries have been installed, since those paths are stored as defaults in the engine and compiler at installation time. Thus, there is no need for setting any environment variables in order to <em>run</em> Ciao executables (on a single architecture -- see <a href="Install.html#Multiarchitecture support">Multiarchitecture support</a> for running on multiple architectures).<p>However, the default paths can be overridden by using the environment variables <tt>CIAOENGINE</tt> and <tt>CIAOLIB</tt>. The first one will tell the Ciao executables where to look for an engine, and the second will tell them where to look for the libraries. Thus, it is possible to actually use the Ciao system without installing it by setting these variables to the following values: <ul> <p><LI><tt>CIAOENGINE</tt>: <tt>$(CIAOSRC)/build/bin/$(CIAOARCH)/ciaoengine</tt> <p><LI><tt>CIAOLIB</tt>: <tt>$(CIAOSRC)</tt> <p></ul> where <tt>$(CIAOARCH)</tt> is the string echoed by the command <tt>CIAOSRC/etc/ciao_get_arch</tt> (or <tt>BINROOT/ciao_get_arch</tt>, after installation).<p>This allows <a class="idx_anchor" id="53" href="ciaoglindex.html#using alternate engines or libraries">using alternate engines or libraries</a>, which can be very useful for system development and experimentation.<p></div><div id="Intermediate files in the compilation process"><h2>Intermediate files in the compilation process</h2> <p>Compiling an individual source (i.e., <tt>.pl</tt>) file produces a <tt>.itf</tt> file and a <tt>.po</tt> file. The <tt>.itf</tt> file contains information of the <a class="idx_anchor" id="54" href="ciaocoindex.html#modular interface"><em>modular interface</em></a> of the file, such as information on exported and imported predicates and on the other modules used by this module. This information is used to know if a given file should be recompiled at a given point in time and also to be able to detect more errors statically including undefined predicates, mismatches on predicate charaterictics across modules, etc. The <tt>.po</tt> file contains the platform-independent object code for a file, ready for linking (statically or dynamically).<p>It is also possible to use <tt>ciaoc</tt> to explicitly generate the <tt>.po</tt> file for one or more <tt>.pl</tt> files by using the <tt>-c</tt> option.<p>If you want to view the wam instructions of one or more <tt>.pl</tt> files you can use the <tt>-w</tt> option. That will generate a <tt>.wam</tt> file with such instructions in a pretty format per each <tt>.pl</tt> file.<p></div><div id="Usage (ciaoc)"><h2>Usage (ciaoc)</h2> <p>The following provides details on the different command line options available when invoking <a class="idx_anchor" id="55" href="ciaoglindex.html#ciaoc"><tt>ciaoc</tt></a>:<p><p> <p><pre>ciaoc &lt;MiscOpts&gt; &lt;ExecOpts&gt; [-o &lt;execname&gt;] &lt;file&gt; ...

  Make an executable from the listed files.  If there is
  more than one file, they must be non-module, and the
  first one must include the main predicate.  The -o
  option allows generating an arbitrary executable name.

ciaoc &lt;MiscOpts&gt; &lt;ExecOpts&gt; -a &lt;publishmod&gt; &lt;module&gt;

  Make an active module executable from &lt;module&gt; with
  address publish module &lt;publishmod&gt;.

ciaoc &lt;MiscOpts&gt; -c  &lt;file&gt; ...

  Compile listed files (make .po objects).

ciaoc &lt;MiscOpts&gt; -w  &lt;file&gt; ...

  Generate WAM code of listed files (in .wam files).

&lt;MiscOpts&gt; can be: [-v] [-ri] [-u &lt;file&gt;]  [-rc] [-op &lt;suffix&gt;] [-L &lt;LibDir&gt;]

&lt;ExecOpts&gt; can be: [-s|-S|-SS &lt;target&gt;|-z|-zl|-e|-l|(-ll &lt;module&gt;)*]
                   (-d &lt;alias&gt;)* [-x]

default extension for files is &apos;.pl&apos;

-h, --help
	Show this help.
-u	use &lt;file&gt; for compilation, often used to include LibDir paths, etc.
-op	use &lt;suffix&gt; as the suffix for optimized (or otherwise tuned) code
-L	look for libraries also in the &lt;LibDir&gt; directory
-c	Compile listed files (make .po objects)
-w	Generate WAM code of listed files (in .wam files).
-S	make standalone executable for the current OS and architecture, implies -s
-SS	make standalone executable for &lt;target&gt; OS and architecture
	valid &lt;target&gt; values may be: LINUXi86, SolarisSparc..., implies -s
-ll	force &lt;module&gt; to be loaded lazily,  implies -l
-ac	All the modules will be compiled using &lt;Packages&gt;
-acm	&lt;Modules&gt; will be compiled using &lt;Packages&gt;
-d	files using this path alias are dynamic (default: library)
-o	Make an executable from the listed files.
-a	Make an active module
-v, --verbose-compilation
	verbose mode
-ri, --itf-format-r
	Generate human readable .itf files
-x, --check-libraries
	extended recompilation: only useful for Ciao standard library developers
-s, --executables-static
	make a static executable (otherwise dynamic files are not included)
-z, --compress-exec
	Generate executables with compressed bytecode
-zl, --compress-lib
	generate libraries with compressed bytecode - any library (re)compiled as
	consequence of normal executable compilation will also be affected
-l, --executables-lazyload
	Idem with lazy load of dynamic files (except insecure cases)
-np, --use-compile-packages-no
	Do not use compile packages
-na, --read-assertions-no
	Do not read the assertions in the code
-rc, --runtime-checks
	Generate code with runtime checks, requires to read assertions
--rtchecks-trust-no
	Disable rtchecks for trust assertions
--rtchecks-entry-no
	Disable rtchecks for entry assertions
--rtchecks-exit-no
	Disable rtchecks for exit assertions
--rtchecks-test
	enable rtchecks for test assertions. Used for debugging
	purposes, but is better to use the unittest library
--rtchecks-level-exports
	Use rtchecks only for external calls of the exported predicates
--rtchecks-inline
	Expand library predicates inline as far as possible
--rtchecks-asrloc-no
	Do not use assertion locators in the error messages
--rtchecks-predloc-no
	Do not use predicate locators in the error messages
--rtchecks-namefmt-short
	Show the name of predicates and properties in a reduced format
--rtchecks-callloc-no
	Do not show the stack of predicates that caused the failure
--rtchecks-callloc-literal
	Show the stack of predicates that caused the failure. Instrument it
	in the literal. This mode provides more information, because reports
	also the literal in the body of the predicate
--unused-pred-warnings
	Show warnings about unused predicates.  Note that a predicate is
	being used if it is exported, it appears in clause body of a
	predicate being used, in a multifile predicate, in a predicate
	used in :- initialization(...) or :- on_abort(...)
	declarations, or if it is the meta-argument of a metapredicate.
</pre> </div><br/><div id="Known bugs and planned improvements"><h2>Known bugs and planned improvements</h2><ul><LI>Run-time checks have been reported not to work with this code. That means that either the assertions here, or the code that implements the run-time checks are erroneous.<LI> Also if appears in the body of an assertion referred to a predicate being used, but that is not implemented, because the assertion reader is not included in the compiler yet -- EMM.</ul></div></div></div></div></div><div class="sidebarwrapper"><div class="sidebar"><IMG SRC="autofigciao-shadow-64h.png"><h2>Global Links</h2><ul><LI><a href="ciaofulltoc.html">Table of Contents</a><LI><a href="ciaochanges.html">Version/Change Log</a><LI><a href="ciaorefs.html">References</a><LI><a href="ciaocopyright.html">Copyright</a></ul><h2>Indices</h2><ul><LI><a href="ciaoliindex.html">Library/Module Index</a><LI><a href="ciaopdindex.html">Predicate/Method Index</a><LI><a href="ciaoprindex.html">Property Index</a><LI><a href="ciaoteindex.html">Regular Type Index</a><LI><a href="ciaodeindex.html">Declaration Index</a><LI><a href="ciaocoindex.html">Concept Index</a><LI><a href="ciaoauindex.html">Author Index</a><LI><a href="ciaoglindex.html">Global Index</a></ul></div></div><div class="clearer"></div></div><div class="nav"><span class="on_right"><a class="navbutton" href="DevEnv.html">&#x25C4;</a><a class="navbutton" href="toplevel_doc.html">&#x25BA;</a></span><span>&nbsp;</span></div><div class="footer">Generated with LPdoc using Ciao</div></body></html>