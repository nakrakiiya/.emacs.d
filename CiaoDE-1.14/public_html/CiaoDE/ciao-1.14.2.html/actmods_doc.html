<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/><link rel="stylesheet" href="lpdoc.css" type="text/css"/><title>Active modules (high-level distributed execution) &mdash; The Ciao System v1.14#2</title></head><body><div class="nav"><span class="on_right"><a class="navbutton" href="when.html">&#x25C4;</a><a class="navbutton" href="agent_doc.html">&#x25BA;</a></span><span><a href="ciao.html">The Ciao System</a> &raquo; <a href="ExtendProlog.html">PART VII - Ciao extensions</a> &raquo; </span></div><div class="documentwrapper"><div class="document"><div class="mainwrapper"><div class="main"><div id=""><h1>Active modules (high-level distributed execution)</h1><a class="idx_anchor" href="ciaoliindex.html#actmods"></a>
<strong>Author(s):</strong> <a class="idx_anchor" id="Manuel Hermenegildo" href="ciaoauindex.html#Manuel Hermenegildo">Manuel Hermenegildo</a>, <a class="idx_anchor" id="Daniel Cabeza" href="ciaoauindex.html#Daniel Cabeza">Daniel Cabeza</a>.<p>
<p>Active modules [<a href="ciaorefs.html#ciao-dis-impl-parimp-www">CH95</a>] provide a high-level model of <a class="idx_anchor" id="0" href="ciaoglindex.html#inter-process communication">inter-process communication</a> and <a class="idx_anchor" id="1" href="ciaoglindex.html#distributed execution">distributed execution</a> (note that this is also possible using Ciao&apos;s communication and concurrency primitives, such as sockets, concurrent predicates, etc., but at a lower level of abstraction). An <a class="idx_anchor" id="2" href="ciaocoindex.html#active module"><em>active module</em></a> (or an <a class="idx_anchor" id="3" href="ciaocoindex.html#active object"><em>active object</em></a>) is an ordinary module to which computational resources are attached, and which resides at a given location on the network. Compiling an active module produces an executable which, when running, acts as a <em>server</em> for a number of predicates: the predicates exported by the module. Predicates exported by an active module can be accessed by a program on the network by simply &ldquo;using&rdquo; the module, which then imports such &ldquo;remote predicates.&rdquo; The process of &ldquo;using&rdquo; an active module does not involve transferring any code, but rather setting up things so that calls in the module using the active module are executed as remote procedure calls to the active module. This occurs in the same way independently of whether the active module and the using module are in the same machine or in different machines across the network.<p>Except for having to compile it in a special way (see below), an active module is identical from the programmer point of view to an ordinary module. A program using an active module imports it and uses it in the same way as any other module, except that it uses &ldquo;<a class="idx_anchor" id="4" href="ciaoglindex.html#use_active_module"><tt>use_active_module</tt></a>&rdquo; rather than &ldquo;<a class="idx_anchor" id="5" href="ciaoglindex.html#use_module"><tt>use_module</tt></a>&rdquo; (see below). Also, an active module has an address (network address) which must be known in order to use it. In order to use an active module it is necessary to know its address: different &ldquo;protocols&rdquo; are provided for this purpose (see below). <P><b>Note:</b> It is also possible to provide active modules via a WWW address. However, we find it more straightforward to simply use socket addresses. In any case, this is generally hidden inside the access method and can be thus made transparent to the user.<P> <p>From the implementation point of view, active modules are essentially daemons: executables which are started as independent processes at the operating system level. Communication with active modules is implemented using sockets (thus, the address of an active module is an IP socket address in a particular machine). Requests to execute goals in the module are sent through the socket by remote programs. When such a request arrives, the process running the active module takes it and executes it, returning through the socket the computed answers. These results are then taken and used by the remote processes. Backtracking over such remote calls works as usual and transparently. The only limitation (this may change in the future, but it is currently done for efficiency reasons) is that all alternative answers are precomputed (and cached) upon the first call to an active module and thus <em>an active module should not export a predicate which has an infinite number of answers</em>.<p>The first thing to do is to select a method whereby the client(s) (the module(s) that will use the active module) can find out in which machine/port (IP address/socket number) the server (i.e., the active module) will be listening once started, i.e., a &ldquo;protocol&rdquo; to communicate with the active module. The easiest way to do this is to make use of the rendezvous methods which are provided in the Ciao distribution in the <tt>library/actmods</tt> directory; currently, <tt>tmpbased...</tt>, <tt>filebased...</tt>, <tt>webbased...</tt>, and <tt>platformbased...</tt>.<p>The first one is based on saving the IP address and socket number of the server in a file in a predefined directory (generally <tt>/tmp</tt>, but this can be changed by changing <tt>tmpbased_common.pl</tt>).<p>The second one is similar but saves the info in the directory in which the server is started (as <em>&lt;module_name&gt;</em><tt>.addr</tt>), or in the directory that a <tt>.addr</tt> file, if it exists, specifies. The clients must be started in the same directory (or have access to a file <tt>.addr</tt> specifying the same directory). However, they can be started in different machines, provided this directory is shared (e.g., by NFS or Samba), or the file can be moved to an appropriate directory on a different machine --provided the full path is the same.<p>The third one is based on a <a class="idx_anchor" id="6" href="ciaoglindex.html#name server">name server</a> for active modules. When an active module is started, it communicates its address to the name server. When the client of the active module wants to communicate with it, it asks the name server the active module address. This is all done transparently to the user. The name server must be running when the active module is started (and, of course, when the application using it is executed). The location of the name server for an application must be specified in an application file named <tt>webbased_common.pl</tt> (see Section 3.1 below).<p>The fourth one is also based on a name server, but the address of the name server is given as a parameter to the active modules when started.<p>The rendezvous methods (or protocols) are encoded in two modules: a first one, called <tt>...publish.pl</tt>, is used by the server to publish its info. The second one, called <tt>...locate.pl</tt>, is used by the client(s) to locate the server info. For efficiency, the client methods maintain a cache of addresses, so that the server information only needs to be read from the file system the first time the active module is accessed.<p>Active modules are compiled using the <tt>-a</tt> option of the Ciao compiler (this can also be done from the interactive top-level shell using <a class="idx_anchor" id="7" href="ciaoglindex.html#make_actmod/2"><tt>make_actmod/2</tt></a>). For example, issuing the following command:<p><pre>  ciaoc -a &apos;actmods/filebased_publish&apos; simple_server
  </pre> <p>compiles the simple server example that comes with the distribution (in the <tt>actmods/example</tt> directory). The <tt>simple_client_with_main</tt> example (in the same directory) can be compiled as usual:<p><pre>  ciaoc simple_client_with_main
  </pre> <p>Note that the client uses the <tt>actmods</tt> package, specifies the rendezvous method by importing <tt>library(actmods(filebased_locate))</tt>, and explicitely imports the &ldquo;remote&rdquo; predicates (<em>implicit imports will not work</em>). Each module using the <tt>actmods</tt> package <em>should only use one of the rendezvous methods</em>.<p>Now, if the server is running (e.g., <tt>simple_server &amp;</tt> in Un*x or double-clicking on it in Win32) when the client is executed it will connect with the server to access the predicate(s) that it imports from it.<p>A simpler even client <a class="idx_anchor" id="8" href="ciaoglindex.html#simple_client.pl"><tt>simple_client.pl</tt></a> can be loaded into the top level and its predicates called as usual (and they will connect with the server if it is running).<p><div id="Active modules as agents"><h2>Active modules as agents</h2> <p>It is rather easy to turn Ciao active modules into agents for some kind of applications. The directory <tt>examples/agents</tt> contains a (hopefully) self-explanatory example.<p></div><br/><div id="Usage and interface"><h2>Usage and interface</h2><div class="cartouche"><ul><LI><strong>Library usage:</strong><br/><tt>:- use_package(actmods).</tt>

or

<tt>:- module(...,...,[actmods]).</tt><LI><strong>New declarations defined:</strong><br/><a class="idx_anchor" id="9" href="ciaoglindex.html#use_active_module/2"><tt>use_active_module/2</tt></a>.
</ul></div></div><div id="Documentation on new declarations"><h2>Documentation on new declarations</h2><div><span class="on_right">DECLARATION</span><div class="defname"><a class="idx_anchor" id="use_active_module/2" href="ciaodeindex.html#use_active_module/2">use_active_module/2</a>:</div><div class="deftext"><p><strong>Usage:</strong> :- <tt>use_active_module(AModule,Imports)</tt>.
<ul class="itemize_minus"><LI><em>Description:</em> Specifies that this code imports from the <em>active module</em> defined in <span class="var">AModule</span> the predicates in <span class="var">Imports</span>. The imported predicates must be exported by the active module. <LI><em>The following properties should hold at call time:</em><br/><span class="on_right"> (streams_basic:sourcename/1)</span><span><span class="var">AModule</span> is a source name.
</span><br/><span class="on_right"> (basic_props:list/2)</span><span><span class="var">Imports</span> is a list of <span class="var">predname</span>s.
</span>
</ul></div></div><p>
</div><div id="Other information"><h2>Other information</h2>
The protocols <tt>webbased</tt> and <tt>platformbased</tt> are described in this section with a bit more detail.<p><div id="Active module name servers (webbased protocol)"><h2>Active module name servers (webbased protocol)</h2> <p>An application using a name server for active modules must have a file named <tt>webbased_common.pl</tt> that specifies where the name server resides. It must have the <tt>URL</tt> and the path which corresponds to that <tt>URL</tt> in the file system of the server machine (the one that hosts the <tt>URL</tt>) of the file that will hold the name server address.<p>The current distribution provides a file <tt>webbased_common.pl</tt> that can be used (after proper setting of its contents) for a server of active modules for a whole installation. Alternatively, particular servers for each application can be set up (see below).<p>The current distribution also provides a module that can be used as name server by any application. It is in file <a class="idx_anchor" id="10" href="ciaoglindex.html#examples/webbased_server/webbased_server.pl"><tt>examples/webbased_server/webbased_server.pl</tt></a>.<p>To set up a name server edit <tt>webbased_common.pl</tt> to change its contents appropriately as described above (<tt>URL</tt> and corresponding complete file path). Then recompile this library module: <pre>    ciaoc -c webbased_common
  </pre> The name server has to be compiled as an active module itself: <pre>    ciaoc -a actmods/webserver_publish webbased_server
  </pre> It has to be started in the server machine before the application and its active modules are compiled.<p>Alternatively, you can copy <tt>webbased_common.pl</tt> and use it to set up name servers for particular applications. Currently, this is a bit complicated. You have to ensure that the name server, the application program, and all its active modules are compiled and executed with the same <tt>webbased_common.pl</tt> module. One way to do this is to create a subdirectory <tt>actmods</tt> under the directory of your application, copy <tt>webbased_common.pl</tt> to it, modify it, and then compile the name server, the application program, and its active modules using a library path that guarantees that your <tt>actmods</tt> directory is located by the compiler before the standard Ciao library. The same applies for when running all of them if the library loading is dynamic.<p>One way to do the above is using the <tt>-u</tt> compiler option. Assume the following file: <pre>     :- module(paths,[],[]).
     :- multifile library_directory/1.
     :- dynamic library_directory/1.
     :- initialization(asserta_fact(
	library_directory(&apos;/root/path/to/my/particular/application&apos;) )).
  </pre> then you have file <tt>webbased_common.pl</tt> in a subdirectory <tt>actmods</tt> of the above cited path. You have to compile the name server, the active modules, and the rest of the application with: <pre>    ciaoc -u paths -s ...
  </pre> to use your particular <tt>webbased_common.pl</tt> and to make executables statically link libraries. If they are dynamic, then you have to provide for the above library_directory path to be set up upon execution. This can be done, for example, by including module <tt>paths</tt> into your executables.<p>Addresses of active modules are saved by the name server in a subdirectory <tt>webbased_db</tt> of the directory where you start it ---see <tt>examples/webbased_server/webbased_db/webbased_server</tt>). This allows to restart the server right away if it dies (since it saves its state). This directory should be cleaned up regularly of addresses of active modules which are no more active. To do this, stop the server ---by killing it (its pid is in <tt>PATH/FILE</tt>), and restart it after cleaning up the files in the above mentioned directory.<p></div><div id="Platforms (platformbased protocol)"><h2>Platforms (platformbased protocol)</h2> <p>This protocol is also based on a name server. There are, however, two differences with the above one: the name server address and the active modules names are dynamic. On the one hand, the name server address (IP address/socket number) is given to the active modules when they are started up. This might be convenient when using the same name server executable for different applications starting up a different name server process for each application. On the other hand, the name assigned to a given active module can also be given as a parameter to the active module when it is started up. This makes it easier to maintain a local name space for particular applications (e.g., two modules with the same name can be used as active modules in the same application).<p>The code of a name server for the previous section protocol can also be used for this protocol (e.g., file <a class="idx_anchor" id="11" href="ciaoglindex.html#examples/webbased_server/webbased_server.pl"><tt>examples/webbased_server/webbased_server.pl</tt></a>). </div><br/></div><div id="Known bugs and planned improvements"><h2>Known bugs and planned improvements</h2><ul><LI>The package provides no means for security: the accessing application must take care of this (?).<LI>It can happen that there is a unique process for an active module serving calls from several different simultaneous executions of the same application (or even different applications). In this case, there might be unwanted interactions (e.g., if the active module has state).<LI>Applications may fail if the name server or an active module is restarted during execution of the application (since they might restart at a different port than the one cached by the application).<LI>One may want name servers to reside at a fixed and known machine and port number (this is known as a <em>service</em> and is defined in <tt>/etc/services</tt> in a Un*x machine).</ul></div></div></div></div></div><div class="sidebarwrapper"><div class="sidebar"><IMG SRC="autofigciao-shadow-64h.png"><h2>Package Sections</h2><ul><LI><a href="#Active modules as agents">Active modules as agents</a><LI><a href="#Usage and interface">Usage and interface</a><LI><a href="#Documentation on new declarations">Documentation on new declarations</a><LI><a href="#Other information">Other information</a><LI><a href="#Active module name servers (webbased protocol)">Active module name servers (webbased protocol)</a><LI><a href="#Platforms (platformbased protocol)">Platforms (platformbased protocol)</a><LI><a href="#Known bugs and planned improvements">Known bugs and planned improvements</a></ul><h2>Global Links</h2><ul><LI><a href="ciaofulltoc.html">Table of Contents</a><LI><a href="ciaochanges.html">Version/Change Log</a><LI><a href="ciaorefs.html">References</a><LI><a href="ciaocopyright.html">Copyright</a></ul><h2>Indices</h2><ul><LI><a href="ciaoliindex.html">Library/Module Index</a><LI><a href="ciaopdindex.html">Predicate/Method Index</a><LI><a href="ciaoprindex.html">Property Index</a><LI><a href="ciaoteindex.html">Regular Type Index</a><LI><a href="ciaodeindex.html">Declaration Index</a><LI><a href="ciaocoindex.html">Concept Index</a><LI><a href="ciaoauindex.html">Author Index</a><LI><a href="ciaoglindex.html">Global Index</a></ul></div></div><div class="clearer"></div></div><div class="nav"><span class="on_right"><a class="navbutton" href="when.html">&#x25C4;</a><a class="navbutton" href="agent_doc.html">&#x25BA;</a></span><span>&nbsp;</span></div><div class="footer">Generated with LPdoc using Ciao</div></body></html>