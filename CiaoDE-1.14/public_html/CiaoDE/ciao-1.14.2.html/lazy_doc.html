<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/><link rel="stylesheet" href="lpdoc.css" type="text/css"/><title>Lazy evaluation &mdash; The Ciao System v1.14#2</title></head><body><div class="nav"><span class="on_right"><a class="navbutton" href="gnuplot.html">&#x25C4;</a><a class="navbutton" href="mycin_doc.html">&#x25BA;</a></span><span><a href="ciao.html">The Ciao System</a> &raquo; <a href="Contrib.html">PART XI - Contributed libraries</a> &raquo; </span></div><div class="documentwrapper"><div class="document"><div class="mainwrapper"><div class="main"><div id=""><h1>Lazy evaluation</h1><a class="idx_anchor" href="ciaoliindex.html#lazy"></a>
<strong>Author(s):</strong> <a class="idx_anchor" id="Amadeo Casas" href="ciaoauindex.html#Amadeo Casas">Amadeo Casas (<tt>http://www.cs.unm.edu/~amadeo</tt>, University of New Mexico)</a>.<p>
This library package allows the use of lazy evaluation in a Ciao module/program.<p>Lazy Evaluation is a program evaluation technique used particularly in functional languages. When using lazy evaluation, an expression is not evaluated as soon as it is assigned, but rather when the evaluator is forced to produce the value of the expression. Although the <tt>when</tt> or <tt>freeze</tt> control primitives present in many modern logic programming systems are more powerful than lazy evaluation, they lack the simplicity of use and cleaner semantics of functional lazy evaluation.<p>The objective of this package is to allow evaluating the functions lazily. Functions are the subset of relations (predicates) which have a designated argument through which a single output is obtained for any set of inputs (the other arguments). In logic programming systems which have syntactic support for functions (including Ciao), functions are typically translated to predicates whose <tt>last</tt> argument is designated as a (single value) output and the rest as inputs.<p>In our proposal, a function can be declared as lazy via the following declaration:<p> <pre>:- lazy fun_eval f/N.
</pre> <p> This function could be represented as:<p><pre>:- lazy fun_eval f(~_,_,_,_).
</pre> <p>where ~ indicates the argument through which the single output will be obtained. Another possible representation may be:<p><pre>:- lazy fun_return f(~_,_,_,_).
</pre> <p> In order to achieve the intended behavior, the execution of each function declared as lazy is suspended until the return value of the function is needed.<p>A simple example of the use of lazy evaluation would be the definition of a function which returns the (potentially) infinite list of integers starting with a given one:<p><pre>:- lazy fun_eval nums_from/1.
nums_from(X) := [X | nums_from(X+1)].
</pre> <p>  While lazy functions certainly increase the overhead in the execution, they also allow the user to develop in an easy way predicates which can handle infinite terms, and this is the main advantage of the proposed functionality.<p>Lazy evaluation can be also a better option than eager evaluation when a function in a different module is used and it returns a big amount of data. As an example, we have the following module <tt>module1</tt>:<p><pre>:- module(module1, [test/1], [fsyntax, lazy, hiord]).

:- use_module(library(lazy(lazy_lib)), [nums_from/2, takeWhile/3]).
:- use_module(module2, [squares/2]).
:- use_module(library(arithpreds)).

:- fun_eval test/0.
test := ~takeWhile((&rdquo;(X) :- X &lt; 10000), ~squares(~nums_from(1))).


</pre> <p>  and another module <tt>module2</tt>:<p> <pre>:- module(module1, [test/1], [fsyntax, lazy, hiord]).

:- use_module(library(lazy(lazy_lib)), [nums_from/2, takeWhile/3]).
:- use_module(module2, [squares/2]).
:- use_module(library(arithpreds)).

:- fun_eval test/0.
test := ~takeWhile((&rdquo;(X) :- X &lt; 10000), ~squares(~nums_from(1))).


</pre> <p>  Function <tt>test/0</tt> in module <tt>m1</tt> needs to execute function <tt>squares/1</tt>, in module <tt>m2</tt>, which will return a very long list (in the case of this example this list will be infinite, but the conclusions also apply with finite but long lists). If <tt>squares/1</tt> were executed eagerly then the entire list would be returned, to immediately execute the <tt>take/2</tt> function with the entire list, but creating this intermediate result is wasteful in terms of memory requirements. In order to solve this problem, the <tt>squares/1</tt> function could be moved to module <tt>m1</tt> and merged with <tt>take/2</tt> (or, also, they could exchange a size parameter). But rearranging the program is not always possible and may perhaps complicate other aspects of the overall program design.<p>If instead the <tt>squares/1</tt> function is evaluated lazily, it is possible to keep the definitions unchanged and in different modules and there will be a smaller memory penalty for storing the intermediate result. As more values are needed by the <tt>take/2</tt> function, more values in the list returned by <tt>squares/1</tt> are built (in this example, only 10 values). These values that have been consumed and passed over will be recovered by the garbage collector and the corresponding memory freed. The query:<p> <pre>?- test(X).
</pre> <p>  will compute <span class="var">X</span> = [1,4,9,16,25,36,49,64,81,100].<p>A library of useful functions has been added to this package to allow the programmer to develop lazy functions easily and with a well-defined syntax. This library is called <strong>lazy_lib.pl</strong> and it provides the following functions:<p> <ul> <p><LI>nums_from(+X,-List): <span class="var">List</span> is unified with an infinite list of successive numbers starting in <span class="var">X</span>.<p><LI>nums_from_inc(+X,+Y,-List): <span class="var">List</span> is unified with an infinite list of successive numbers starting in <span class="var">X</span> with an increment of <span class="var">Y</span>.<p><LI>repeat(+X,-List): <span class="var">List</span> is unified with an infinite list of the term <span class="var">Y</span>.<p><LI>cycle(+X,-List): <span class="var">List</span> is unified with an infinite list of the term <span class="var">Y</span> repeated infinite times.<p><LI>take(+X,+ListA,-ListR): <span class="var">ListR</span> is unified with the first <span class="var">X</span> elements of the infinite list <span class="var">ListA</span>.<p><LI>takeWhile(+P,+ListA,-ListR): <span class="var">ListR</span> is unified with the first elements of the infinite list <span class="var">ListA</span> while the condition <span class="var">P</span> is true.<p><LI>drop(+X,+ListA,-ListR): <span class="var">ListR</span> is unified with the infinite list <span class="var">ListA</span> dropping the first <span class="var">X</span> elements.<p><LI>dropWhile(+P,+ListA,-ListR): <span class="var">ListR</span> is unified with the infinite list <span class="var">ListA</span> dropping the first elements while the condition <span class="var">P</span> is true.<p><LI>splitAt(+X,+ListA,-Res): <span class="var">Res</span> is unified with a tuple of lists where the first list is composed by the first <span class="var">X</span> elements of the list <span class="var">ListA</span> and the second list is composed by the rest of the elements of <span class="var">ListA</span>.<p><LI>span(+P,+ListA,-Res): <span class="var">Res</span> is unified with a tuple of lists where the first list is composed by the elements of <span class="var">ListA</span> which verify the condition <span class="var">P</span> and the second list is composed by the rest of the elements of the initial list.<p><LI>tail(+ListA,-ListR): <span class="var">ListR</span> is unified with the tail of the infinite list <span class="var">ListA</span>.<p><LI>lazy_map(+ListA,+P,-ListR): Version of the map/3 predicate to be executed lazily.<p><LI>lazy_foldl(+ListA,+X,+P,-ListR): Version of the foldl/3 predicate to be executed lazily.<p><LI>zipWith(+P,+ListA,+ListB,-ListR): <span class="var">ListR</span> is a list whose elements are calculated from the function <span class="var">P</span> and the elements of input lists <span class="var">ListA</span> and <span class="var">ListB</span> occuring at the same position in both lists.<p></ul> <p><br/><div id="Usage and interface"><h2>Usage and interface</h2><div class="cartouche"><ul><LI><strong>Library usage:</strong><br/><tt>:- use_package(lazy).</tt>

or

<tt>:- module(...,...,[lazy]).</tt><LI><strong>New operators defined:</strong><br/><a class="idx_anchor" id="0" href="ciaoglindex.html#lazy/1"><tt>lazy/1</tt></a> [1170,fx].
<LI><strong>Other modules used:</strong><br/><ul class="itemize_minus"><LI><em>System library modules:</em><br/><a class="idx_anchor" id="1" href="ciaoglindex.html#freeze/freeze"><tt>freeze/freeze</tt></a>.
</ul></ul></div></div><div id="Other information"><h2>Other information</h2>
The translation of the code in order to execute it lazily is explained below.<p>A sentence translation is provided to handle the <tt>lazy</tt> directives. The translation of a lazy function into a predicate is done in two steps. First, the function is converted into a predicate (using the fsyntax package). Then, the resulting predicate is transformed to suspend its execution until the value of the last variable (i.e., the output variable) is needed. This suspension is achieved by the use of the <tt>freeze/1</tt> control primitive that many modern logic programming systems implement quite efficiently (<tt>block</tt> or <tt>when</tt> declarations can obviously also be used, but we explain the transformation in terms of <tt>freeze</tt> because it is more widespread). The translation will rename the original predicate to an internal name and add a bridge predicate with the original name which invokes the internal predicate through a call to <tt>freeze/1</tt>. This will delay the execution of the internal predicate until its result is required, which will be detected as a binding (i.e., demand) of its output variable.<p>We show now an example of the use of lazy evaluation, and how a lazy function is translated by this package. The following code returns an (infinite) list of fibonacci numbers:<p> <pre>:- lazy fun_eval fiblist/0.
fiblist := [0, 1 | ~zipWith(add, FibL, ~tail(FibL))]
        :- FibL = fiblist.
</pre> <p>  which is translated into:<p> <pre>fiblist(X) :- 
          freeze(X, &apos;fiblist_$$lazy$$&apos;(X)).

&apos;fiblist_$$lazy$$&apos;([0, 1 | Rest]) :- 
          fiblist(FibL), 
          tail(FibL, T), 
          zipWith(add, FibL, T, Rest).
</pre> <p>  In the <tt>fiblist</tt> function defined, any element in the resulting infinite list of fibonacci numbers can be referenced, as for example, <tt>nth(X, ~fiblist, Value).</tt>. The other functions used in the definition are <tt>tail/2</tt> and <tt>zipWith/3</tt>. These two functions can be found in the <strong>lazy_lib.pl</strong> runtime file.<p><br/></div></div></div></div></div><div class="sidebarwrapper"><div class="sidebar"><IMG SRC="autofigciao-shadow-64h.png"><h2>Package Sections</h2><ul><LI><a href="#Usage and interface">Usage and interface</a><LI><a href="#Other information">Other information</a></ul><h2>Global Links</h2><ul><LI><a href="ciaofulltoc.html">Table of Contents</a><LI><a href="ciaochanges.html">Version/Change Log</a><LI><a href="ciaorefs.html">References</a><LI><a href="ciaocopyright.html">Copyright</a></ul><h2>Indices</h2><ul><LI><a href="ciaoliindex.html">Library/Module Index</a><LI><a href="ciaopdindex.html">Predicate/Method Index</a><LI><a href="ciaoprindex.html">Property Index</a><LI><a href="ciaoteindex.html">Regular Type Index</a><LI><a href="ciaodeindex.html">Declaration Index</a><LI><a href="ciaocoindex.html">Concept Index</a><LI><a href="ciaoauindex.html">Author Index</a><LI><a href="ciaoglindex.html">Global Index</a></ul></div></div><div class="clearer"></div></div><div class="nav"><span class="on_right"><a class="navbutton" href="gnuplot.html">&#x25C4;</a><a class="navbutton" href="mycin_doc.html">&#x25BA;</a></span><span>&nbsp;</span></div><div class="footer">Generated with LPdoc using Ciao</div></body></html>